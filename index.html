<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      document.documentElement.classList.add("js");
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Upstate Sound &amp; Repair – Boutique audio service in Greenville, SC
    </title>

    <!-- Fonts + (optional) your external stylesheet -->
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Space+Grotesk:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css?v=4" />
    <!-- Inline favicon to avoid 404 /favicon.ico requests -->
    <link
      rel="icon"
      type="image/svg+xml"
      href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none"%3E%3Crect width="64" height="64" rx="12" fill="%230a0a0a"/%3E%3Cpath d="M6 32c6-10 12 10 18 0s12-10 18 0 12 10 18 0" stroke="%237dd3fc" stroke-width="6" stroke-linecap="round" fill="none"/%3E%3C/svg%3E'
    />
    <link
      rel="shortcut icon"
      href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none"%3E%3Crect width="64" height="64" rx="12" fill="%230a0a0a"/%3E%3Cpath d="M6 32c6-10 12 10 18 0s12-10 18 0 12 10 18 0" stroke="%237dd3fc" stroke-width="6" stroke-linecap="round" fill="none"/%3E%3C/svg%3E'
    />

    <style>
      /* ---------- Page frame / background gutters ---------- */
      :root {
        --bg-x: 50%;
        --bg-y: 50%;
        --bg-pattern-image: url("assets/background-light.svg");
        --bg-overlay: linear-gradient(
          0deg,
          rgba(10, 10, 10, 0.45),
          rgba(10, 10, 10, 0.45)
        );
        --hero-bg-image: var(--bg-pattern-image);
        --hero-overlay-light: linear-gradient(
          180deg,
          rgba(250, 249, 246, 0) 0%,
          rgba(10, 10, 10, 0.08) 45%,
          rgba(10, 10, 10, 0.6) 100%
        );
        --hero-overlay-dark: linear-gradient(
          180deg,
          rgba(19, 30, 54, 0) 0%,
          rgba(12, 18, 32, 0.54) 55%,
          rgba(5, 8, 16, 0.82) 100%
        );
        --hero-overlay: var(--hero-overlay-light);
      }
      html {
        background-image: var(--bg-overlay), var(--bg-pattern-image);
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: cover;
        background-position: var(--bg-x) var(--bg-y);
      }
      html.dark-mode {
        --bg-pattern-image: url("assets/background-dark.svg");
        --hero-bg-image: var(--bg-pattern-image);
        --bg-overlay: linear-gradient(
          0deg,
          rgba(5, 8, 16, 0.5),
          rgba(5, 8, 16, 0.5)
        );
        --morph-stroke-color: #7dd3fc; /* brighter cyan pops on dark */
        --hero-overlay: var(--hero-overlay-dark);
      }
      html.light-mode {
        --morph-stroke-color: #2f6f64;
      }
      html.party {
        --morph-stroke-color: #7dd3fc;
      }
      body {
        margin: 0;
        color: #e6e6e6;
        font-family: "Space Grotesk", system-ui, sans-serif;
        background: transparent;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -1;
        pointer-events: none;
        background-image: var(--bg-overlay), var(--bg-pattern-image);
        background-repeat: no-repeat;
        background-size: cover;
        background-position: var(--bg-x) var(--bg-y);
      }

      :root {
        /* Seafoam glow palette (matches background shapes) */
        --glow-main: 47, 111, 100; /* #2F6F64 */
        --glow-halo: 31, 85, 77; /* a darker teal for the halo */

        /* runtime‑tunable vars */
        --drift-scale: 1;
        --morph-stroke-color: #2f6f64; /* default seafoam */
        --morph-stroke-min: 18;
        --morph-stroke-max: 28;
        --wave-speed: 0.001; /* 50% faster than 0.0006 */
        --wave-cycles: 4; /* number of undulations across the viewport */
        --morph-opacity: 0.24; /* try 0.18 ~ 0.35 */
      }

      /* Content column handles layout while the morph wave floats as a sibling overlay */
      .content-frame {
        position: relative;
        max-width: 1100px;
        margin: 0 auto;
        background: transparent; /* bg moved to ::before so morph can sit above it */
        min-height: 100dvh;
        z-index: 2; /* creates local stacking context */
        overflow: visible;
      }
      .content-frame::before {
        content: "";
        position: fixed; /* fixed so column bg doesn’t scroll */
        left: 50vw;
        top: 0;
        transform: translateX(-50%);
        width: min(1100px, 92vw);
        height: 100dvh; /* dynamic viewport for iOS bars */
        background: rgba(
          10,
          10,
          10,
          0.92
        ); /* translucent tint only; let single background show through */
        z-index: 0;
      }

      /* iOS Safari: emulate background-attachment: fixed via a fixed body::before layer.
         Mobile Safari ignores/bugs fixed backgrounds on html/body, which causes the
         hero/header to visually slip. This layer pins the image to the viewport. */
      @supports (-webkit-touch-callout: none) {
        html {
          background: transparent !important;
        }
        body::before {
          /* stabilize compositing */
          transform: translateZ(0);
          will-change: transform;
        }
      }

      /* Landscape tablets can crop differently; nudge the image up a bit for alignment */
      @media (orientation: landscape) and (min-width: 900px) and (max-height: 900px) {
        :root {
          --bg-y: 46%;
        }
      }

      /* ===== MORPH: fixed, full-bleed overlay (sits above column background, below content) ===== */
      .morph-wrap {
        position: fixed;
        left: 0 !important;
        right: 0 !important;
        top: 50vh;
        transform: translateY(-50%);
        width: 100vw !important;
        height: 70vh;
        display: block;
        z-index: 60; /* above sections so it’s never hidden */
        pointer-events: none;
        opacity: 0.24; /* visible but not overpowering */
        mix-blend-mode: screen; /* additive light so it doesn’t block text */
      }
      .morph-wrap svg {
        width: 100%;
        height: 100%;
        overflow: visible;
        display: block;
      }

      /* Make the morph path obey the CSS var color */
      .morph-wrap svg path[data-blend] {
        stroke: var(--morph-stroke-color, #2f6f64) !important;
      }

      /* Sections / cards: sections have a lower z-index than the morph now */
      .section {
        position: relative;
        z-index: 20;
        padding: 64px 24px;
      }
      .section.alt {
        background: #111;
      }

      h1,
      h2,
      h3 {
        margin: 0 0 16px;
        font-family: "Montserrat", system-ui, sans-serif;
        color: #f4f4f5;
      }
      p {
        color: #c9c9ce;
        line-height: 1.6;
      }

      /* ---------- Header / Hero ---------- */
      #hero {
        position: relative;
        padding: 80px 24px 48px;
        text-align: center;
      }
      .hero-overlay {
        position: absolute;
        inset: 0;
        background: var(--hero-overlay);
        pointer-events: none;
        z-index: 0;
      }
      .logo {
        display: block;
        margin: 0 auto 24px;
        height: auto;
      }

      /* Size inline SVG placed inside .logo container */
      .logo svg {
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto 24px;
      }

      /* Tagline “tape wobble” + glow for contrast */
      .tape {
        display: inline-block;
        animation: tapeWobble 1.2s ease-in-out infinite;
        transform-origin: 50% 50%;
      }
      @keyframes tapeWobble {
        0% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
        25% {
          transform: translateY(-1px) rotate(0.22deg) skewX(-0.1deg);
        }
        50% {
          transform: translateY(0.6px) rotate(-0.14deg) skewX(0.06deg);
        }
        75% {
          transform: translateY(-0.8px) rotate(0.18deg) skewX(-0.06deg);
        }
        100% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .tape {
          animation: none;
        }
      }

      /* Tagline glow (seafoam-only) */
      #hero h1.tape {
        text-shadow: 0 0 3px rgba(var(--glow-main), 0.55),
          0 0 8px rgba(var(--glow-halo), 0.4),
          0 0 16px rgba(var(--glow-main), 0.22);
      }

      .logo {
        isolation: isolate;
      } /* prevent blending weirdness with backdrop */
      .logo svg,
      .logo svg * {
        /* Subtle seafoam glow to match tagline */
        filter: drop-shadow(0 0 2px rgba(var(--glow-main), 0.42))
          drop-shadow(0 0 5px rgba(var(--glow-halo), 0.32))
          drop-shadow(0 0 10px rgba(var(--glow-main), 0.18));
        transition: filter 120ms ease-out;
      }

      /* Nav (desktop/tablet default) */
      #nav {
        position: absolute;
        top: 12px;
        right: 18px;
        display: flex;
        justify-content: flex-end;
        gap: 24px;
        margin-bottom: 12px;
        align-items: center;
      }
      #nav a {
        color: #b9b9ff;
        text-decoration: none;
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      #nav-toggle {
        display: none;
      }

      /* Glitch links */
      a.glitch {
        position: relative;
        display: inline-block;
        text-decoration: none;
      }
      a.glitch::before,
      a.glitch::after {
        content: attr(data-text);
        position: absolute;
        inset: 0;
        opacity: 0;
        mix-blend-mode: screen;
      }
      a.glitch::before {
        color: #22d3ee;
      }
      a.glitch::after {
        color: #a78bfa;
      }
      @keyframes glitchX {
        0% {
          transform: translate(0, 0);
        }
        20% {
          transform: translate(1px, -1px);
        }
        40% {
          transform: translate(-1px, 1px);
        }
        60% {
          transform: translate(2px, 0);
        }
        80% {
          transform: translate(-2px, 1px);
        }
        100% {
          transform: translate(0, 0);
        }
      }
      a.glitch:hover::before,
      a.glitch:hover::after {
        opacity: 0.7;
        animation: glitchX 0.18s steps(2, end) infinite;
      }

      /* Services grid (base = desktop 3 cols) */
      .services-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 28px;
      }
      .service-card {
        background: #f4f2eb;
        color: #142;
        border-radius: 12px;
        padding: 22px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }
      .service-card.loading {
        cursor: progress;
        opacity: 0.8;
      }
      .service-card.error {
        outline: 2px solid rgba(251, 113, 133, 0.4);
      }
      @media (hover: hover) and (pointer: fine) {
        .service-card:hover {
          outline: 1px solid rgba(255, 255, 255, 0.08);
          transform: translateY(-1px);
          transition: transform 120ms ease-out, outline-color 120ms ease-out;
        }
      }
      .service-card h3 {
        color: #0b2340;
      }
      .service-card p {
        color: #213;
      }

      /* Sticky Services title */
      .services-sticky {
        position: sticky;
        top: 0;
        z-index: 20;
        background: linear-gradient(#0a0a0acc, #0a0a0acc);
        backdrop-filter: blur(4px);
        padding: 10px 24px;
        margin: -10px -24px 16px;
      }

      /* Past work */
      .work-section ul {
        padding-left: 20px;
      }
      .work-section li {
        margin: 12px 0;
      }

      /* Paper panel for About */
      .paper {
        background: #f4f2eb;
        color: #111;
        border-radius: 12px;
        padding: 24px clamp(16px, 2vw, 28px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.18);
      }
      .paper h2 {
        color: #111;
      }
      .paper p {
        color: #222;
      }

      /* Footer */
      .footer {
        padding: 32px 24px;
        text-align: center;
        color: #aaa;
      }

      /* Reveal + drift (CSS vars written by JS) */
      [data-animate] {
        opacity: 1;
        --revealY: 0px;
        --dy: 0px;
        --dx: 0px;
        transform: translate3d(var(--dx), calc(var(--revealY)+var(--dy)), 0);
      }
      .js [data-animate] {
        opacity: 0;
        --revealY: 24px;
        transition: opacity 0.7s cubic-bezier(0.22, 1, 0.36, 1),
          transform 0.7s cubic-bezier(0.22, 1, 0.36, 1);
        will-change: transform, opacity;
      }
      .reveal {
        opacity: 1 !important;
        --revealY: 0px;
      }

      /* Progress bar */
      #scroll-progress {
        position: fixed;
        inset: 0 auto auto 0;
        height: 3px;
        width: 0%;
        background: linear-gradient(90deg, #22d3ee, #a78bfa);
        z-index: 9999;
      }

      /* ====== PARTY MODE VISUALS (revived) ====== */
      @keyframes hueRoll {
        from {
          filter: hue-rotate(0);
        }
        to {
          filter: hue-rotate(360deg);
        }
      }
      @keyframes slowTilt {
        0% {
          transform: rotate(0.02deg);
        }
        50% {
          transform: rotate(-0.02deg);
        }
        100% {
          transform: rotate(0.02deg);
        }
      }
      @keyframes glowPulse {
        0% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
        50% {
          text-shadow: 0 0 12px rgba(var(--glow-halo), 0.75),
            0 0 26px rgba(var(--glow-main), 0.48);
        }
        100% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
      }
      /* Richer/faster hue cycle for cards in party (Konami) mode */
      @keyframes hueSpinRich {
        from {
          filter: hue-rotate(0deg) saturate(1) contrast(1.05) brightness(1);
        }
        50% {
          filter: hue-rotate(180deg) saturate(1.7) contrast(1.12)
            brightness(1.06);
        }
        to {
          filter: hue-rotate(360deg) saturate(1) contrast(1.05) brightness(1);
        }
      }
      /* Apply to normal grid cards and floating cards; also colorize during Float Mode */
      /* Float/Party color model: all cards go black; only the playing one glows */
      html.party .flying-card,
      html.float-on .flying-card {
        background: var(--base, #0a0a0a);
        color: #fff;
        filter: none;
        animation: none;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.28);
      }
      html.party .flying-card .title-swap,
      html.float-on .flying-card .title-swap {
        color: #fff;
      }
      html.party .flying-card:not(.playing),
      html.float-on .flying-card:not(.playing) {
        filter: none; /* keep their individual dark base colors visible */
      }
      html.party .flying-card.playing,
      html.float-on .flying-card.playing {
        outline: 2px solid var(--accent, #7dd3fc);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }
      html.party .content-frame::before {
        background: rgba(
          10,
          10,
          10,
          0.85
        ); /* a hair lighter so the RGB bands show through */
      }
      /* Canvas overlay that draws the live waveform on the active card */
      .flying-card .wave,
      .service-card .wave {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        pointer-events: none;
        opacity: 0.85;
        mix-blend-mode: screen;
      }
      /* During launch shrink, disable input */
      .flying-card.no-drag {
        pointer-events: none !important;
      }
      /* Wave should never steal input */
      .flying-card .wave {
        pointer-events: none !important;
      }
      /* Extra emphasis for the currently playing card */
      .flying-card.playing,
      .service-card.playing {
        box-shadow: inset 0 0 0 2px rgba(var(--glow-main), 0.55),
          0 10px 24px rgba(0, 0, 0, 0.28), 0 0 16px rgba(var(--glow-main), 0.32),
          0 0 28px rgba(var(--glow-halo), 0.26);
      }
      /* Brief hold flash when a drag begins */
      html.party .flying-card.held,
      html.float-on .flying-card.held {
        /* Dark inner ring to contrast the bright overlay, plus a subtle accent rim */
        outline: none;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.55),
          /* deeper drop */ inset 0 0 0 3px rgba(0, 0, 0, 0.65),
          /* dark inner ring */ inset 0 0 12px rgba(0, 0, 0, 0.5),
          /* inner dark glow */ 0 0 16px
            color-mix(in srgb, var(--accent, #7dd3fc) 40%, transparent); /* faint accent */
        transition: box-shadow 160ms ease-out;
      }
      html.party .content-frame {
        animation: hueRoll 14s linear infinite;
      }
      html.party .section {
        animation: slowTilt 7s ease-in-out infinite;
      }
      html.party a,
      html.party h1,
      html.party h2,
      html.party h3,
      html.party .reveal {
        animation: glowPulse 1.8s ease-in-out infinite;
      }
      /* Keep the wobble AND add the glow for the tagline */
      html.party #tagline {
        animation: tapeWobble 1.2s ease-in-out infinite,
          glowPulse 1.8s ease-in-out infinite;
      }
      /* Film grain canvas shown only in party-mode */
      #grain {
        position: fixed;
        inset: 0;
        z-index: 8000;
        pointer-events: none;
        opacity: 0.28;
        display: none;
      }
      html.party #grain {
        display: block;
        opacity: 0.42;
      } /* stronger in party */
      /* Symmetric gutter tint in party mode (both left and right) */
      html.party::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 6500; /* above content column bg, below morph (7000) and grain (8000) */
        background: linear-gradient(
          to right,
          rgba(10, 10, 10, 0.38),
          rgba(10, 10, 10, 0) 22%,
          rgba(10, 10, 10, 0) 78%,
          rgba(10, 10, 10, 0.38)
        );
      }
      /* Keep morph centered & viewport-fixed in party/float modes */
      html.party .morph-wrap,
      html.float-on .morph-wrap {
        position: fixed !important;
        top: 50vh !important;
        left: 0 !important;
        right: 0 !important;
        transform: translateY(-50%) !important;
        z-index: 7000 !important; /* below grain (8000) and lab (9000) */
        mix-blend-mode: normal; /* reduce blending cost while floating */
        opacity: 0.18;
      }

      /* Layer that holds drifting cards (fixed, overlays viewport) */
      #float-layer {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 8500;
        pointer-events: none; /* default: no capture */
        display: none; /* hidden until active */
        overflow: visible;
      }
      html.float-on #float-layer,
      html.party #float-layer {
        display: block;
        pointer-events: none; /* overlay never blocks scroll */
        touch-action: manipulation; /* preserve native scrolling */
      }

      /* Keep site navigation interactive above floating layer */
      #nav {
        z-index: 9001; /* above #float-layer (8500) */
        pointer-events: auto;
      }

      /* Avoid expensive background filter while floating (mobile perf) */
      html.party .content-frame::before,
      html.float-on .content-frame::before {
        filter: none !important;
      }

      /* Ensure PIXI overlay never steals input */
      #pixi-overlay {
        pointer-events: none !important;
      }
      canvas.pixi-overlay {
        pointer-events: none !important;
      }
      /* Redundant combo rule to be absolutely safe */
      #pixi-overlay,
      canvas.pixi-overlay {
        pointer-events: none !important;
      }
      /* Root card handles clicks; children do not */
      .flying-card {
        pointer-events: auto !important;
      }
      .flying-card * {
        pointer-events: none !important;
      }

      /* Float Mode (uses the actual six service cards) */
      .flying-card {
        position: absolute; /* inside #float-layer */
        z-index: 1;
        will-change: transform, opacity;
        contain: layout paint;
        backface-visibility: hidden;
        pointer-events: auto; /* clickable for audio */
        transform: translate3d(0, 0, 0);
        transform-origin: center center; /* ensures rotations spin around center */
        left: 0;
        top: 0; /* transform origin is the viewport’s top-left */
        user-select: none; /* avoid text selection while drifting */
        /* ensure the first paint uses the on-card transform we set from JS */
      }
      /* Ensure the root card is always the single click/drag target and never selects text */
      .flying-card {
        user-select: none;
        -webkit-user-select: none;
        -webkit-user-drag: none;
        -webkit-tap-highlight-color: transparent;
      }
      /* Only the root card handles input so the whole card is reliably clickable */
      .flying-card * {
        pointer-events: none;
      }
      .flying-card .title-swap {
        position: absolute;
        left: 12px;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 700;
        color: #0b2340;
        text-align: center;
        line-height: 1.2;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none; /* prevent accidental selection while floating */
      }
      .flying-card.swap-on .title-swap {
        opacity: 1;
      }
      .flying-card.swap-on h3,
      .flying-card.swap-on p {
        opacity: 0 !important;
        visibility: hidden !important;
        display: none !important;
        height: 0 !important;
        margin: 0 !important;
        pointer-events: none !important;
      }

      /* --- Hover/press lift for floating cards + accessible focus --- */
      html.float-on .flying-card:hover,
      html.party .flying-card:hover {
        z-index: 8700;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.38),
          0 0 18px var(--accent, #7dd3fc);
      }

      html.float-on .flying-card:active,
      html.party .flying-card:active {
        transform: translate3d(var(--fx, 0px), var(--fy, 0px), 0)
          rotate(var(--fa, 0rad)) scale(0.98);
      }

      a:focus-visible,
      button:focus-visible,
      .service-card:focus-visible,
      .flying-card:focus-visible {
        outline: 2px dashed #b9b9ff;
        outline-offset: 3px;
        border-radius: 10px;
      }

      /* === Float launch visuals (size shrink + soft pulse) === */
      /* Quick-change: service cards fly off-stage to the left when Party begins */
      @keyframes flyOutLeft {
        0% {
          transform: translate(0, 0) rotate(0deg) scale(1);
          opacity: 1;
          filter: blur(0);
        }
        60% {
          transform: translate(-26vw, -6vh) rotate(-4deg) scale(0.94);
          opacity: 0.6;
          filter: blur(1px);
        }
        100% {
          transform: translate(-42vw, -8vh) rotate(-8deg) scale(0.88);
          opacity: 0;
          filter: blur(2px);
        }
      }
      .services-section .service-card.vanish {
        animation: flyOutLeft 380ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
        will-change: transform, opacity, filter;
      }
      .flying-card {
        transition: width 320ms cubic-bezier(0.22, 1, 0.36, 1),
          height 320ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 260ms ease;
      }
      .flying-card.launching {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35),
          0 0 0 0 rgba(125, 211, 252, 0);
      }
      .flying-card.launching.playing {
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }

      /* =========================
         RESPONSIVE LAYOUT LAYER
         ========================= */

      /* Tablet (821px–1099px): 2 columns */
      @media (max-width: 1099px) {
        .services-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      /* =========================
         MOBILE FIX PACK (≤ 820px)
         ========================= */
      @media (max-width: 820px) {
        :root {
          --morph-stroke-min: 16;
          --morph-stroke-max: 28;
        }
        :root {
          --drift-scale: 0.75;
        }
        /* Column “paper”: fill more of the screen but keep gutter image visible */
        .content-frame::before {
          width: min(100vw, 96vw);
          background: rgba(10, 10, 10, 0.95);
        }

        /* Sections: tighter padding for readability */
        .section {
          padding: 40px 18px;
        }

        /* Hero: logo + tagline scale and glow for contrast */
        #hero h1.tape {
          font-size: clamp(22px, 7vw, 36px);
          line-height: 1.08;
          text-shadow: 0 0 4px rgba(var(--glow-main), 0.6),
            0 0 10px rgba(var(--glow-halo), 0.44),
            0 0 18px rgba(var(--glow-main), 0.3);
        }

        /* Nav: real mobile menu (button toggles .open) */
        #nav {
          align-items: center;
          justify-content: space-between;
          gap: 0;
        }
        #nav-toggle {
          display: inline-block;
          font-size: 22px;
          background: transparent;
          color: #b9b9ff;
          border: 0;
        }
        /* collapse links by default */
        #nav .glitch {
          display: none;
          padding: 12px 0;
        }
        #nav .glitch + .glitch {
          border-top: 1px solid rgba(255, 255, 255, 0.06);
        }
        /* show when nav is opened */
        #nav.open .glitch {
          display: block;
        }

        /* Services: single column, bigger touch targets */
        .services-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .service-card {
          padding: 18px 16px;
          border-radius: 10px;
          box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        }
        .service-card h3 {
          font-size: clamp(18px, 5.2vw, 22px);
        }
        .service-card p {
          font-size: clamp(14px, 4.2vw, 16px);
          line-height: 1.55;
        }

        /* Sticky “Services” title: less jumpy */
        .services-sticky {
          top: 0;
          padding: 10px 16px;
          margin: -10px -16px 12px;
          background: linear-gradient(#0a0a0acc, #0a0a0acc);
          backdrop-filter: blur(4px);
        }

        /* Past Work spacing */
        .work-section li {
          margin: 10px 0;
        }

        /* Morph: a bit smaller/taller for clarity on phones */
        .morph-wrap {
          width: 100vw;
          height: 55vh;
          opacity: 0.24;
          mix-blend-mode: screen;
        }
        .morph-wrap svg {
          width: 100%;
          height: 100%;
        }

        /* Footer: breathing room */
        .footer {
          padding: 28px 16px;
          font-size: 14px;
        }

        /* Disable keyboard-only hints: Konami is long‑press / double‑tap on mobile */
        .services-sticky {
          position: sticky;
        } /* keep */
        #grain {
          opacity: 0.22;
        } /* slightly softer on phone */

        /* Thumb-sized floating song cards (mobile only) */
        html.float-on .flying-card,
        html.party .flying-card {
          width: clamp(88px, 22vw, 120px) !important;
          height: clamp(88px, 22vw, 120px) !important;
          padding: 10px !important;
          border-radius: 12px !important;
        }

        html.float-on .flying-card .title-swap,
        html.party .flying-card .title-swap {
          font-size: clamp(10px, 3.4vw, 13px) !important;
          line-height: 1.15 !important;
          left: 6px;
          right: 6px;
        }

        html.float-on .flying-card .wave,
        html.party .flying-card .wave {
          opacity: 0.9;
        }
      }

      /* Ultra-small devices (≤ 380px) */
      @media (max-width: 380px) {
        .section {
          padding: 32px 14px;
        }
        .services-sticky {
          margin: -10px -14px 10px;
          padding: 10px 14px;
        }
      }

      /* Dark/Light mode styles */
      body.light-mode {
        background: transparent;
        color: #222;
      }
      body.dark-mode {
        background: transparent;
        color: #eee;
      }
      .theme-toggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        background: none;
        border: 1px solid #ccc;
        border-radius: 20px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 1rem;
        z-index: 1000;
      }
    </style>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <body>
    <!-- Dark/Light mode toggle button -->
    <button class="theme-toggle" aria-label="Toggle dark/light mode">🌙</button>

    <div id="scroll-progress" aria-hidden="true"></div>
    <canvas id="grain" aria-hidden="true"></canvas>
    <audio id="player" preload="metadata" style="display: none"></audio>
    <div id="float-layer" aria-hidden="true"></div>
    <!-- Morph sits above the column background but below content cards -->
    <div class="morph-wrap" aria-hidden="true">
      <div id="morph-svg"></div>
    </div>
    <!-- Content column (bg via ::before) -->
    <div class="content-frame">
      <header id="hero" class="section" data-animate>
        <nav id="nav" data-animate>
          <button id="nav-toggle" aria-label="Toggle navigation">☰</button>
          <a href="#about" class="glitch" data-text="About" data-animate
            >About</a
          >
          <a href="#services" class="glitch" data-text="Services" data-animate
            >Services</a
          >
          <a href="#work" class="glitch" data-text="Past Work" data-animate
            >Past Work</a
          >
          <a href="#contact" class="glitch" data-text="Contact" data-animate
            >Contact</a
          >
        </nav>

        <div class="hero-overlay"></div>
        <div
          class="logo"
          id="logo-inline"
          aria-label="Upstate Sound &amp; Repair logo"
          data-animate
        ></div>
        <h1 id="tagline" class="tape" data-parallax data-drift="1.2">
          Where Sound Meets Vision.
        </h1>
      </header>

      <main>
        <!-- About -->
        <section id="about" class="section about-section paper" data-animate>
          <h2 data-animate>About</h2>
          <p data-animate>
            Hey, I’m Donald—a lifelong chaser of tone and tinkerer of broken
            gear. I’m an audio engineer, live-sound tech, repair whisperer, and,
            on rare occasions, a musician who actually finishes a song. If
            you’re here, you probably care about your gear as much as your
            music—so do I.
          </p>
          <p data-animate>
            Upstate Sound &amp; Repair is my way of keeping our little corner of
            the world humming, one recalcitrant circuit at a time. I consult for
            venues, help artists chase good sound, and I show up when your
            vintage Moog throws a tantrum or your podcast needs a little love.
            If you want work done right (but not uptight), I’m the guy who shows
            up with a soldering iron, way too many opinions, and a sense of
            humor.
          </p>
        </section>

        <!-- Services -->
        <section
          id="services"
          class="section services-section alt"
          data-animate
        >
          <h2 class="services-sticky" data-animate>Services</h2>
          <div class="services-grid">
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Studio &amp; Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Your studio is only as good as its weakest link. I diagnose and
                repair mixers, preamps, tape machines, and all those vintage
                boxes you can’t live without. Think of me as your gear’s
                therapist — I listen carefully and I don’t judge.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Synth &amp; Audio Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Analog synths are living, breathing beasts — and they get
                cranky. I service and restore vintage synthesizers, drum
                machines, samplers and outboard gear. Whether it’s a cracked
                membrane or a blown capacitor, I’ll get the soul back in your
                circuits.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Music Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                I partner with bands and solo artists to produce, record and
                shape their music. From pre-production and arrangement to mixing
                and mastering, I help you capture what you hear in your head and
                translate it to tape. No cookie-cutter templates — just honest
                collaboration and sonic exploration.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Podcast Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Have a story to tell? I provide recording, editing and mixing
                for podcasts and audio books. I’ll help you sound like you know
                what you’re doing — crisp vocals, balanced levels, and maybe the
                occasional tasteful synth stab.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Live Sound Engineering
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                From tiny clubs to weird warehouse gatherings, I mix live shows
                that feel like they’re meant for you. Clean, loud and
                feedback-free. Yes, I’ll carry cases and tape cables because I’m
                not above grunt work.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Consulting &amp; Education
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                One-on-one consulting for studios, bands, and venues.
                Signal-flow bootcamps, mix reviews, live rig sanity checks, and
                hands-on solder sessions. Learn the why, not just the settings.
              </p>
            </div>
          </div>
        </section>

        <!-- Past Work -->
        <section id="work" class="section work-section" data-animate>
          <h2 data-animate>Past Work</h2>
          <ul class="work-list">
            <li data-animate data-drift="0.8">
              <strong>Live &amp; Session Engineer – Artis-Naples:</strong>
              engineered recordings for the Naples Philharmonic Orchestra and
              various chamber ensembles at Artis-Naples (home of the Naples
              Philharmonic).
            </li>
            <li data-animate data-drift="0.8">
              <strong>Mix Consultant – Swansons Studios:</strong> partnered with
              Britt to fine-tune session mixes for local bands, offering fresh
              ears, technical fixes and workflow hacks.
            </li>
            <li data-animate data-drift="0.8">
              <strong
                >Producer &amp; Mix Engineer – 10-Song LP (in progress):</strong
              >
              producing, recording, mixing and mastering a full-length album —
              custom synth patches, recorded instruments, a few talk-radio
              samples — 100% handcrafted, all original.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Podcast Producer – Trailside Carolina:</strong> recorded,
              produced, mixed and mastered the Trailside Carolina podcast —
              crystal-clear audio and immersive storytelling for outdoor
              enthusiasts.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Gear Repair Repertoire:</strong> Yamaha DX7/DX7IIFD, CS01,
              CS50/60, SK-20, Microkorg, Lexicon 300, Korg SK1, Kawai K1, Roland
              JP-3000 &amp; RE-201, Ibanez TS-9, Mu-Tron III, Fender Twin
              (reissue), Pro Reverb (1967), Musicman HD-150, ART PRO VLA II, A
              Designs MP-2A… and many more.
            </li>
          </ul>
        </section>

        <!-- Contact -->
        <section id="contact" class="section contact-section" data-animate>
          <h2 data-animate>Contact</h2>
          <p data-animate>
            Ready to get that crackling amp sorted, record a new podcast or just
            chat about synths? Drop me a line — I’m based in Greenville, South
            Carolina and I love meeting fellow audio nerds.
          </p>
          <p data-animate>
            Email me at
            <a
              class="glitch"
              href="mailto:info@upstatesound.co"
              data-text="info@upstatesound.co"
              >info@upstatesound.co</a
            >.
          </p>
        </section>
      </main>

      <footer class="footer">
        <p>
          © <span id="year"></span> Upstate Sound &amp; Repair. Serving
          Greenville and the Upstate. Made with solder and soul.
        </p>
      </footer>
    </div>
    <!-- .content-frame -->

    <!-- Optional: your existing JS -->
    <script
      src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      // ====== PIXI VHS/CRT OVERLAY (viewport-fixed, no input capture) ======
      (function () {
        // Guard: PIXI must be available
        if (!window.PIXI) {
          window.__pixiVhsReady = false;
          return;
        }

        try {
          // Create a fixed overlay sized to the viewport
          const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundAlpha: 0,
            antialias: false,
            autoDensity: true,
            resolution: window.devicePixelRatio || 1,
          });

          const view = app.view;
          view.id = "pixi-overlay";
          view.className = "pixi-overlay";
          view.style.position = "fixed";
          view.style.inset = "0";
          view.style.zIndex = "8400"; // below Float (#float-layer: 8500)
          view.style.pointerEvents = "none"; // never intercept input
          view.style.display = "none"; // only visible in .party
          view.setAttribute("aria-hidden", "true");
          document.body.appendChild(view);

          // Fullscreen plate we render the filter onto
          const plate = new PIXI.Sprite(PIXI.Texture.WHITE);
          plate.anchor.set(0, 0);
          plate.width = app.renderer.width;
          plate.height = app.renderer.height;
          plate.tint = 0x000000; // base black; color comes from shader
          plate.alpha = 1.0;
          app.stage.addChild(plate);

          // Aggressive VHS/CRT shader:
          //  - rolling scanlines + RGB triad phosphor mask
          //  - chromatic aberration shimmer
          //  - periodic full‑frame warp & horizontal tear bands
          //  - mild barrel distortion / line curl
          //  - animated colored glitch streaks
          // NOTE: This is an OVERLAY; it does not sample page content — it paints
          // translucent light/noise over the page to create the CRT look without blocking clicks.
          const frag = `
            precision mediump float;

            uniform float uTime;
            uniform vec2  uRes;
            uniform float uIntensity;  // master 0..1
            uniform float uNoise;      // grain 0..1
            uniform float uCurl;       // barrel strength 0..0.35
            uniform float uTearRate;   // avg seconds between big tears
            uniform float uTriad;      // triad mask strength 0..1
            uniform float uSpeckle;    // white speckle density 0..1
            uniform float uEdgePower;  // right-edge band strength 0..1
            uniform float uBandSpeed;  // rolling band speed
            varying vec2  vTextureCoord;

            // Hash / noise helpers
            float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }
            float noise(vec2 p){
              vec2 i = floor(p), f = fract(p);
              float a = hash(i);
              float b = hash(i + vec2(1.0, 0.0));
              float c = hash(i + vec2(0.0, 1.0));
              float d = hash(i + vec2(1.0, 1.0));
              vec2 u = f*f*(3.0-2.0*f);
              return mix(a, b, u.x) + (c - a)*u.y*(1.0-u.x) + (d - b)*u.x*u.y;
            }

            // Periodic impulses (0..1) — used to trigger warps/tears
            float impulse(float t, float period, float width){
              float ph = fract(t / period);
              return smoothstep(0.0, width, ph) * (1.0 - smoothstep(width, width*2.0, ph));
            }

            void main(){
              // Base UV (0..1)
              vec2 uv = vTextureCoord;
              float t = uTime;

              // Mild barrel distortion / line curl
              vec2 centered = (uv - 0.5) * 2.0;          // -1..1
              float r2 = dot(centered, centered);
              float k  = uCurl;                           // ~0.08 default
              centered *= (1.0 + k * r2);
              uv = centered * 0.5 + 0.5;

              // Row-dependent horizontal jitter (tracking instability)
              float row = floor(uv.y * uRes.y);
              float jitter = (hash(vec2(row, floor(t * 24.0))) * 2.0 - 1.0) * (0.0018 + 0.0012 * uIntensity);
              uv.x += jitter;

              // Rolling scanline phase & triad mask
              float scan = 0.6 + 0.4 * sin((uv.y * uRes.y) * 3.14159);
              float tri  = fract(uv.x * uRes.x / 3.0);
              float triad = step(0.66, tri) - step(0.33, tri);
              triad = abs(triad);
              float mask = mix(1.0, mix(0.70, 1.0, triad), clamp(uTriad, 0.0, 1.0));

              // Moving bright band (tracking) + chroma bleed
              float band = smoothstep(0.0, 1.0, 0.5 + 0.5 * sin(t*max(0.01,uBandSpeed) + uv.y*8.0));
              float bandAmt = 0.12 * uIntensity;

              // Fine grain + horizontal jitter noise
              float grains = noise(vec2(uv.x * uRes.x * 0.65, uv.y * uRes.y * 0.18) + t*2.0) - 0.5;
              float jitterRow = noise(vec2(uv.y * 140.0, t * 4.0)) - 0.5;
              float n = grains * (0.55 * uNoise) + jitterRow * (0.35 * uNoise);

              // RGB channel phase offsets (sub-pixel misalignment)
              float shift = (sin(t*0.9) * 0.75 + 1.0) * 0.0028;
              vec3 baseRGB = vec3(
                (scan * (0.82 + 0.18 * sin(t*0.7 + 0.0))) * mask,
                (scan * (0.82 + 0.18 * sin(t*0.8 + 2.1))) * mask,
                (scan * (0.82 + 0.18 * sin(t*0.9 + 4.2))) * mask
              );
              baseRGB += band * bandAmt;

              // Horizontal noise lines drifting upward (VHS scanline interference)
              float hstripe = smoothstep(0.785, 1.0, sin((uv.y - t*0.03) * 46.0));
              hstripe *= (0.16 + 0.12 * uIntensity);
              baseRGB += vec3(0.60, 0.50, 0.70) * hstripe;

              // Noisy right-edge head-switching band (flickery vertical strip)
              float edgeMask = smoothstep(0.985, 0.998, uv.x); // near right edge
              float edgeGrain = noise(vec2(t*3.0, uv.y*260.0)) - 0.5;
              float edgeScan  = sin((uv.y * uRes.y * 0.7 - t * 90.0)); // dense scan shimmer
              float zig = abs(fract(uv.y*22.0 + t*0.4) - 0.5)*2.0; // triangular wave 0..1
              float notches = smoothstep(0.65, 0.98, zig);
              float edgeComb  = clamp(0.6*abs(edgeScan) + 0.8*abs(edgeGrain), 0.0, 1.0) * notches;
              baseRGB += edgeMask * edgeComb * vec3(1.0, 0.96, 0.88) * (0.2 + 0.6*uEdgePower);

              // Sparse white speckles / dropouts
              float sp = hash(vec2(floor(uv.x*uRes.x*0.7)+t*47.0, floor(uv.y*uRes.y*0.7)+t*113.0));
              float speck = step(1.0 - 0.0025*clamp(uSpeckle,0.0,1.0), sp);
              baseRGB += speck * vec3(1.0) * (0.5 + 0.3*uIntensity);

              // Periodic full‑frame wobble (low‑freq sinusoidal warp)
              float wobble = sin(t * 1.2) * 0.004 * uIntensity;
              baseRGB *= 1.0 + wobble;

              // Horizontal tear band every few seconds (with random height)
              float tearClock = t / max(0.001, uTearRate);         // avg period
              float tearTrig  = impulse(t, uTearRate, 0.12);       // 0..1 spike
              float tearY     = fract(sin(floor(tearClock)) * 43758.5453);
              float tearPos   = mix(0.08, 0.92, tearY);            // 8%..92% down the screen
              float bandWidth = mix(0.006, 0.02, fract(tearY * 17.0));
              float tearBand  = smoothstep(tearPos - bandWidth, tearPos, uv.y) *
                                (1.0 - smoothstep(tearPos, tearPos + bandWidth, uv.y));
              float tearAmp   = 0.18 * tearTrig * uIntensity;
              // Brighten a little and add a colored smear in the band
              baseRGB += tearBand * tearAmp * vec3(1.0, 0.6, 0.9);

              // Vignette to soften edges (CRT glass)
              vec2 d = (uv - 0.5);
              float vign = 1.0 - dot(d, d) * 1.6;
              baseRGB *= clamp(vign, 0.0, 1.0);

              // Apply grain / noise on top
              baseRGB += n * 0.35;

              // Overall alpha — keep the site readable
              float alpha = clamp(0.16 + 0.18 * uIntensity, 0.08, 0.42);
              gl_FragColor = vec4(baseRGB, alpha);
            }
          `;

          const uniforms = {
            uTime: 0,
            uRes: new PIXI.Point(app.renderer.width, app.renderer.height),
            uIntensity: 1.0, // 0..1 master
            uNoise: 0.75, // grain strength
            uCurl: 0.085, // barrel/line curl
            uTearRate: 3.5, // seconds between tear events (avg)
            uTriad: 1.0, // strong triad mask
            uSpeckle: 0.35, // some white speckles
            uEdgePower: 0.9, // strong right edge
            uBandSpeed: 0.9, // default band speed
          };

          const filter = new PIXI.Filter(undefined, frag, uniforms);
          plate.filters = [filter];

          // Resize handler keeps everything matched to the viewport
          function fit() {
            const w = Math.max(1, window.innerWidth);
            const h = Math.max(1, window.innerHeight);
            app.renderer.resize(w, h);
            plate.width = w;
            plate.height = h;
            uniforms.uRes.set(w, h);
          }
          window.addEventListener("resize", fit, { passive: true });
          fit();

          // Animate shader time
          app.ticker.add((delta) => {
            uniforms.uTime += delta / 60.0;
          });

          // Toggle visibility with .party on <html>
          function syncVisibility() {
            const on = document.documentElement.classList.contains("party");
            view.style.display = on ? "block" : "none";
          }
          syncVisibility();
          new MutationObserver(syncVisibility).observe(
            document.documentElement,
            {
              attributes: true,
              attributeFilter: ["class"],
            }
          );

          // Optional public knob for future Lab controls
          window.__pixiVhsSet = function (opts) {
            if (!opts) return;
            if (typeof opts.intensity === "number")
              uniforms.uIntensity = Math.max(0, Math.min(1, opts.intensity));
            if (typeof opts.noise === "number")
              uniforms.uNoise = Math.max(0, Math.min(1, opts.noise));
            if (typeof opts.curl === "number")
              uniforms.uCurl = Math.max(0.0, Math.min(0.35, opts.curl));
            if (typeof opts.tearRate === "number")
              uniforms.uTearRate = Math.max(0.8, opts.tearRate);
            if (typeof opts.triad === "number")
              uniforms.uTriad = Math.max(0, Math.min(1, opts.triad));
            if (typeof opts.speckle === "number")
              uniforms.uSpeckle = Math.max(0, Math.min(1, opts.speckle));
            if (typeof opts.edge === "number")
              uniforms.uEdgePower = Math.max(0, Math.min(1, opts.edge));
            if (typeof opts.bandSpeed === "number")
              uniforms.uBandSpeed = Math.max(
                0.01,
                Math.min(6.0, opts.bandSpeed)
              );
          };

          window.__pixiVhsReady = true;
          window.__pixiApp = app;
        } catch (e) {
          console.warn("PIXI VHS overlay failed:", e);
          window.__pixiVhsReady = false;
        }
      })();
    </script>

    <!-- Vibe core -->
    <script>
      (function () {
        var d = document.documentElement,
          b = document.body;

        /* Inline the logo.svg so CSS glow can target its paths */
        (function () {
          // === Waveform rendering on the active card ==========================
          var __waveCard = null,
            __waveCtx = null,
            __waveCvs = null,
            __waveRAF = 0;

          function attachWaveToCard(card) {
            if (!card) return;
            var cvs = card.querySelector(".wave");
            if (!cvs) {
              cvs = document.createElement("canvas");
              cvs.className = "wave";
              card.appendChild(cvs);
            }
            // Ensure overlay behavior regardless of external CSS
            cvs.style.position = "absolute";
            cvs.style.inset = "0";
            cvs.style.width = "100%";
            cvs.style.height = "100%";

            __waveCvs = cvs;
            __waveCtx = cvs.getContext("2d");

            // fit to card box (device-pixel perfect sizing)
            function size() {
              var r = card.getBoundingClientRect();
              var w = Math.max(2, Math.floor(r.width));
              var h = Math.max(2, Math.floor(r.height));
              if (cvs.width !== w) cvs.width = w;
              if (cvs.height !== h) cvs.height = h;
            }
            size();
            // re-fit on next frame (after CSS/layout settles)
            var rafId = requestAnimationFrame(size);
            // track future resizes for responsive cards
            if (window.ResizeObserver) {
              if (cvs.__ro) cvs.__ro.disconnect();
              var ro = new ResizeObserver(size);
              ro.observe(card);
              cvs.__ro = ro;
            } else {
              // fallback: resize on window resize
              if (!cvs.__onResize) {
                cvs.__onResize = size;
                window.addEventListener("resize", size, { passive: true });
              }
            }
            __waveCard = card;
          }

          function stopWave() {
            if (__waveRAF) cancelAnimationFrame(__waveRAF);
            __waveRAF = 0;
            if (__waveCard) {
              var c = __waveCard.querySelector(".wave");
              if (c) {
                c.getContext("2d").clearRect(0, 0, c.width, c.height);
                // cleanup observers/listeners attached in attachWaveToCard
                if (c.__ro) {
                  try {
                    c.__ro.disconnect();
                  } catch (_) {}
                  c.__ro = null;
                }
                if (c.__onResize) {
                  window.removeEventListener("resize", c.__onResize);
                  c.__onResize = null;
                }
              }
              __waveCard.classList.remove("playing");
            }
            __waveCard = null;
          }

          function startWaveOn(card) {
            if (!window.__waveAnalyser || !card) return;
            attachWaveToCard(card);
            card.classList.add("playing");

            var analyser = window.__waveAnalyser;
            var buf = new Uint8Array(analyser.fftSize);

            function draw() {
              if (!__waveCtx || !__waveCvs) return;
              analyser.getByteTimeDomainData(buf);

              var w = __waveCvs.width,
                h = __waveCvs.height;
              var ctx = __waveCtx;
              ctx.clearRect(0, 0, w, h);

              // soft glow trail
              ctx.lineWidth = 3;
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.shadowBlur = 14;
              ctx.shadowColor = "rgba(255,255,255,0.9)";
              ctx.beginPath();

              for (var i = 0; i < buf.length; i++) {
                var x = (i / (buf.length - 1)) * w;
                var y = (buf[i] / 255) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.stroke();
              __waveRAF = requestAnimationFrame(draw);
            }
            stopWave(); // stop previous
            __waveRAF = requestAnimationFrame(draw);
          }
          // Expose waveform helpers globally
          window.__startWaveOn = startWaveOn;
          window.__stopWave = stopWave;
          var holder = document.getElementById("logo-inline");
          if (!holder) return;
          fetch("assets/logo.svg")
            .then(function (r) {
              return r.text();
            })
            .then(function (svg) {
              holder.innerHTML = svg;
            })
            .catch(function (e) {
              console.warn("inline logo failed", e);
            });
        })();

        /* CONTINUOUS WAVE MORPH (centered, section-aware, audio-capable) */
        (function initWave() {
          var host = document.getElementById("morph-svg");
          if (!host) return;

          function vw() {
            return Math.max(
              1,
              window.innerWidth || document.documentElement.clientWidth || 1
            );
          }
          var W = vw();
          var H = Math.max(360, innerHeight);
          var wrap = document.querySelector(".morph-wrap");
          if (wrap) {
            wrap.style.width = "100vw";
            wrap.style.left = "0";
            wrap.style.right = "0";
          }
          var midY = H / 2;
          var xStart = 0;
          var xEnd = W;

          var svgNS = "http://www.w3.org/2000/svg";
          var svg = document.createElementNS(svgNS, "svg");
          svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          svg.setAttribute("preserveAspectRatio", "none");

          var outline = document.createElementNS(svgNS, "path");
          outline.setAttribute("fill", "none");
          outline.setAttribute("stroke", "rgba(0,0,0,0.28)");
          outline.setAttribute("stroke-linecap", "round");
          outline.setAttribute("stroke-linejoin", "round");
          svg.appendChild(outline);

          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "currentColor");
          path.setAttribute("stroke-linecap", "round");
          path.setAttribute("stroke-linejoin", "round");
          path.setAttribute("data-blend", "");
          svg.appendChild(path);
          host.innerHTML = "";
          host.appendChild(svg);

          var root = document.documentElement;
          function readNumVar(name, fallback) {
            var v = parseFloat(getComputedStyle(root).getPropertyValue(name));
            return isNaN(v) ? fallback : v;
          }
          function isFloating() {
            var html = document.documentElement;
            return (
              html.classList.contains("party") ||
              html.classList.contains("float-on")
            );
          }
          function sampleDensity() {
            // Lower path point density while floating for mobile perf
            return isFloating() ? 0.45 : 1.0;
          }
          function strokeMin() {
            return readNumVar("--morph-stroke-min", 9);
          }
          function strokeMax() {
            return readNumVar("--morph-stroke-max", 13);
          }
          function strokeColor() {
            var c = getComputedStyle(root)
              .getPropertyValue("--morph-stroke-color")
              .trim();
            return c || "#2f6f64";
          }
          path.style.stroke = strokeColor();
          path.style.mixBlendMode = "screen";
          path.style.strokeOpacity = "1";
          outline.setAttribute("stroke-opacity", "0.18");
          path.style.opacity = "0.70";
          path.setAttribute("stroke-width", strokeMin());

          // Wave parameters
          var cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4)));
          var k = (Math.PI * 2 * cycles) / (xEnd - xStart);
          var phase = 0;
          var speed = readNumVar("--wave-speed", 0.0018);
          var amp = Math.min(H * 0.42, 340);
          var N = Math.max(420, Math.floor((xEnd - xStart) * sampleDensity()));

          // Section → waveform map
          var targetShape = "sine";
          var sectionMap = [
            ["hero", "sine"],
            ["about", "square"],
            ["services", "triangle"],
            ["work", "saw"],
            ["contact", "static"],
          ];
          if ("IntersectionObserver" in window) {
            var io = new IntersectionObserver(
              function (entries) {
                entries.forEach(function (e) {
                  if (e.isIntersecting) {
                    for (var i = 0; i < sectionMap.length; i++) {
                      if (e.target.id === sectionMap[i][0]) {
                        targetShape = sectionMap[i][1];
                        break;
                      }
                    }
                  }
                });
              },
              { threshold: 0.55 }
            );
            sectionMap.forEach(function (pair) {
              var el = document.getElementById(pair[0]);
              if (el) io.observe(el);
            });
          }

          // Optional audio analyser
          var analyser = window.__waveAnalyser || null;
          var buf = analyser ? new Uint8Array(analyser.fftSize) : null;

          function lerp(a, b, t) {
            return a + (b - a) * t;
          }
          function sign(x) {
            return x < 0 ? -1 : 1;
          }
          function toPathD(xs, ys) {
            var d = "M" + xs[0] + "," + ys[0];
            for (var i = 1; i < xs.length; i++) {
              d += " L" + xs[i] + "," + ys[i];
            }
            return d;
          }
          function shapeY(nx, ph, kind) {
            var x = xStart + nx * (xEnd - xStart);
            var tt = k * x + ph;
            switch (kind) {
              case "sine":
                return Math.sin(tt);
              case "square":
                return sign(Math.sin(tt));
              case "triangle":
                return (2 / Math.PI) * Math.asin(Math.sin(tt));
              case "saw": {
                var u = (tt / (2 * Math.PI)) % 1;
                return 2 * u - 1;
              }
              case "static":
                return (Math.random() * 2 - 1) * 0.15;
              default:
                return Math.sin(tt);
            }
          }

          var currentShape = "sine";
          var morphT = 1; // 1=at current, 0=finished morph to target

          var __waveTick = 0;
          function frame() {
            // While floating, update the path every other frame to reduce CPU
            if (isFloating() && ++__waveTick & 1) {
              requestAnimationFrame(frame);
              return;
            }
            path.style.stroke = strokeColor();
            phase += speed;
            var sw = lerp(
              strokeMin(),
              strokeMax(),
              (Math.sin(phase * 0.5) + 1) / 2
            );
            path.setAttribute("stroke-width", sw.toFixed(2));
            outline.setAttribute("stroke-width", (sw + 2).toFixed(2));
            outline.style.mixBlendMode = "screen";

            if (currentShape !== targetShape) {
              morphT -= 0.06;
              if (morphT <= 0) {
                currentShape = targetShape;
                morphT = 0;
              }
            } else {
              morphT = Math.min(1, morphT + 0.06);
            }

            if (window.__waveAnalyser && !analyser) {
              analyser = window.__waveAnalyser;
              buf = new Uint8Array(analyser.fftSize);
            }
            if (analyser) {
              analyser.getByteTimeDomainData(buf);
            }

            var xs = new Array(N),
              ys = new Array(N);
            for (var i = 0; i < N; i++) {
              var nx = i / (N - 1);
              xs[i] = xStart + nx * (xEnd - xStart);
              var base;
              if (analyser) {
                var idx = Math.floor(nx * (buf.length - 1));
                base = (buf[idx] - 128) / 128;
              } else {
                base = shapeY(nx, phase, currentShape);
              }
              if (morphT < 1) {
                var toY = shapeY(nx, phase, targetShape);
                base = lerp(toY, base, morphT);
              }
              ys[i] = midY + base * amp;
            }
            outline.setAttribute("d", toPathD(xs, ys));
            path.setAttribute("d", toPathD(xs, ys));
            requestAnimationFrame(frame);
          }
          requestAnimationFrame(frame);

          function resync() {
            W = vw();
            H = Math.max(360, innerHeight);
            midY = H / 2;
            xStart = 0;
            xEnd = W;
            cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4)));
            k = (Math.PI * 2 * cycles) / (xEnd - xStart);
            N = Math.max(420, Math.floor((xEnd - xStart) * sampleDensity()));
            amp = Math.min(H * 0.42, 340);
            svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          }
          addEventListener("resize", resync);
        })();

        /* ===== Audio Unlock (one-time), global helpers ===== */
        (function () {
          var unlocked = false;
          function prime() {
            if (unlocked) return true;
            try {
              var AC = window.AudioContext || window.webkitAudioContext;
              if (!AC) return false;
              var ctx = (window.__audioCtx = window.__audioCtx || new AC());
              // resume context (iOS requires gesture)
              if (ctx.state === "suspended" && ctx.resume) ctx.resume();
              var player = document.getElementById("player");
              if (!player) return false;
              // Connect once to analyser so the waveform always works after first gesture
              if (!window.__waveAnalyser) {
                var srcNode = ctx.createMediaElementSource(player);
                var analyser = ctx.createAnalyser();
                analyser.fftSize = 1024;
                srcNode.connect(analyser);
                analyser.connect(ctx.destination);
                window.__waveAnalyser = analyser;
              }
              // Prime the element by a quick play/pause inside the gesture
              var p = player.play();
              if (p && typeof p.catch === "function") p.catch(function () {});
              player.pause();
              unlocked = true;
              console.log("[audio] context unlocked");
              return true;
            } catch (_) {
              return false;
            }
          }
          window.__primeAudio = prime;
          // One-time capture on first touchend
          var onFirstTouch = function () {
            prime();
            window.removeEventListener("touchend", onFirstTouch, true);
          };
          window.addEventListener("touchend", onFirstTouch, true);
        })();

        /* ====== Party Mode controller (K key + Konami, calls __startFloatMode) ====== */
        (function () {
          // idempotent guard
          if (window.__partyControllerReady) return;
          window.__partyControllerReady = true;

          function enableParty() {
            const html = document.documentElement;
            if (!html.classList.contains("party")) {
              html.classList.add("party");
            }
            // start Float Mode physics if not already running
            if (typeof window.__startFloatMode === "function") {
              window.__startFloatMode();
            }
            // Inject a viewport meta to disable double-tap zoom while allowing pinch
            try {
              var meta = document.querySelector('meta[name="viewport"]');
              if (meta) {
                meta.__orig = meta.getAttribute("content");
                meta.setAttribute(
                  "content",
                  "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=yes"
                );
              }
            } catch (_) {}
          }

          function disableParty() {
            document.documentElement.classList.remove("party");
            if (typeof window.__stopFloatMode === "function") {
              window.__stopFloatMode();
            }
            // Restore original viewport meta
            try {
              var meta = document.querySelector('meta[name="viewport"]');
              if (meta && meta.__orig)
                meta.setAttribute("content", meta.__orig);
            } catch (_) {}
          }

          function toggleParty() {
            if (document.documentElement.classList.contains("party"))
              disableParty();
            else enableParty();
          }

          // Simple 'k' toggle
          window.addEventListener("keydown", function (e) {
            const key = e.key || "";
            if (key.toLowerCase() === "k") {
              e.preventDefault();
              toggleParty();
            }
          });

          // Konami code
          const KONAMI = [
            "ArrowUp",
            "ArrowUp",
            "ArrowDown",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
            "ArrowLeft",
            "ArrowRight",
            "b",
            "a",
          ];
          let idx = 0;
          window.addEventListener("keydown", function (e) {
            const k = e.key || "";
            const key = k.length === 1 ? k.toLowerCase() : k;
            const expect = KONAMI[idx];
            if (
              key === expect ||
              (expect.length === 1 && key === expect.toLowerCase())
            ) {
              idx++;
              if (idx === KONAMI.length) {
                idx = 0;
                enableParty();
              }
            } else {
              // reset smartly if first key of sequence matches current key
              idx = key === KONAMI[0] ? 1 : 0;
            }
          });

          // Mobile secrets: long-press logo to toggle Party
          (function () {
            var isTouch =
              matchMedia("(pointer: coarse)").matches ||
              "ontouchstart" in window;
            if (!isTouch) return;
            var logo = document.getElementById("logo-inline");
            if (!logo) return;
            var t0 = 0,
              id = null,
              startX = 0,
              startY = 0,
              moved = false;
            function clear() {
              if (id) {
                clearTimeout(id);
                id = null;
              }
            }
            logo.addEventListener(
              "touchstart",
              function (e) {
                if (!e.touches || !e.touches[0]) return;
                t0 = performance.now();
                moved = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                clear();
                id = setTimeout(function () {
                  if (!moved) {
                    e.preventDefault();
                    /* gesture qualified */ toggleParty();
                  }
                }, 600);
              },
              { passive: true }
            );
            logo.addEventListener(
              "touchmove",
              function (e) {
                if (!e.touches || !e.touches[0]) return;
                var dx = e.touches[0].clientX - startX,
                  dy = e.touches[0].clientY - startY;
                if (dx * dx + dy * dy > 100) {
                  moved = true;
                  clear();
                }
              },
              { passive: true }
            );
            logo.addEventListener(
              "touchend",
              function () {
                clear();
              },
              { passive: true }
            );
          })();

          // Shake to toggle (with iOS permission + small toast if denied)
          (function () {
            var last = 0,
              debounced = false;
            var TOGGLE_GAP = 1500;
            var SHAKE = 12; // m/s^2 approx
            function tryToggle() {
              var now = Date.now();
              if (now - last > TOGGLE_GAP) {
                last = now;
                toggleParty();
              }
            }
            function onMotion(ev) {
              var a = ev.accelerationIncludingGravity || ev.acceleration || {};
              var ax = a.x || 0,
                ay = a.y || 0,
                az = a.z || 0;
              var mag = Math.sqrt(ax * ax + ay * ay + az * az);
              if (mag > SHAKE) tryToggle();
            }
            function toast(msg) {
              var n = document.createElement("div");
              n.textContent = msg;
              Object.assign(n.style, {
                position: "fixed",
                bottom: "12px",
                left: "50%",
                transform: "translateX(-50%)",
                background: "#111",
                color: "#fff",
                padding: "6px 10px",
                borderRadius: "6px",
                fontSize: "12px",
                opacity: "0.9",
                zIndex: "99999",
              });
              document.body.appendChild(n);
              setTimeout(() => {
                n.remove();
              }, 3000);
            }
            if (typeof DeviceMotionEvent !== "undefined") {
              if (typeof DeviceMotionEvent.requestPermission === "function") {
                // prompt on first user interaction
                window.addEventListener(
                  "touchend",
                  function ask() {
                    DeviceMotionEvent.requestPermission()
                      .then(function (res) {
                        if (res === "granted")
                          window.addEventListener("devicemotion", onMotion, {
                            passive: true,
                          });
                        else toast("Shake disabled");
                      })
                      .catch(function () {
                        toast("Shake disabled");
                      });
                    window.removeEventListener("touchend", ask, true);
                  },
                  true
                );
              } else {
                window.addEventListener("devicemotion", onMotion, {
                  passive: true,
                });
              }
            }
          })();

          // Expose helpers for testing
          window.__partyOn = enableParty;
          window.__partyOff = disableParty;
        })();

        /* === Float Mode (Matter.js orbital drift) — unique physics, free rotation, per-card colors === */
        (function () {
          var player = document.getElementById("player");
          var layer = document.getElementById("float-layer");
          if (!layer) {
            layer = document.createElement("div");
            layer.id = "float-layer";
            document.body.appendChild(layer);
          }
          // Appearance is controlled purely via CSS classes (see #float-layer rules)

          // Titles ↔ tracks (1:1 with service cards on the page)
          var TITLES = [
            "Resting Place",
            "Deletions of Grandeur",
            "God of No Man",
            "Is There a Number to The Other Side?",
            "Sad News",
            "Spiritually Dead",
          ];
          var TRACKS = [
            "assets/audio/resting-place.m4a",
            "assets/audio/deletions-of-grandeur.m4a",
            "assets/audio/god-of-no-man.m4a",
            "assets/audio/is-there-a-number-to-the-other-side.m4a",
            "assets/audio/sad-news.m4a",
            "assets/audio/spiritually-dead.m4a",
          ];
          // Darker party palette per card
          var BASES = [
            "#0b1f2a",
            "#10231f",
            "#1e1722",
            "#231b10",
            "#122018",
            "#1b2130",
          ];

          // High-contrast accents (used for the playing card + morph stroke)
          var ACCENTS = [
            "#7dd3fc",
            "#a78bfa",
            "#fb7185",
            "#f59e0b",
            "#34d399",
            "#60a5fa",
          ];

          // Matter primitives
          var Engine = window.Matter && Matter.Engine;
          var Bodies = window.Matter && Matter.Bodies;
          var Composite = window.Matter && Matter.Composite;
          var Runner = window.Matter && Matter.Runner;
          var Events = window.Matter && Matter.Events;
          var Mouse = window.Matter && Matter.Mouse;
          var MouseConstraint = window.Matter && Matter.MouseConstraint;
          var engine = null,
            runner = null;
          var __idleT = 0; // seconds since float mode started (for independent idle drift)
          var bodies = []; // {el, body, w, h}
          var ticking = 0;
          var ACTIVE = false;

          // --- Scroll-triggered turbulence (makes things jumble like pebbles) ---
          var burstUntil = 0;
          function jostle(durationMs, power) {
            var now = performance.now();
            burstUntil = Math.max(burstUntil, now + (durationMs || 220));
            if (!power) power = 1;

            function turbulenceFrame() {
              var t = performance.now();
              if (t >= burstUntil) return;
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i].body;
                // lighter small random forces in both axes + a touch of spin
                var fx = (Math.random() - 0.5) * 0.0016 * power;
                var fy = (Math.random() - 0.5) * 0.0016 * power;
                Matter.Body.applyForce(b, b.position, { x: fx, y: fy });
                b.angularVelocity += (Math.random() - 0.5) * 0.028 * power;
              }
              requestAnimationFrame(turbulenceFrame);
            }
            requestAnimationFrame(turbulenceFrame);
          }

          if (player) {
            player.addEventListener(
              "playing",
              function () {
                var card = player.__currentCard;
                if (card) {
                  card.classList.remove("loading", "error");
                  card.classList.add("playing");
                }
              },
              { passive: true }
            );
            ["pause", "ended"].forEach(function (evt) {
              player.addEventListener(
                evt,
                function () {
                  var card = player.__currentCard;
                  if (card) card.classList.remove("loading", "playing");
                },
                { passive: true }
              );
            });
            player.addEventListener(
              "waiting",
              function () {
                var card = player.__currentCard;
                if (card) card.classList.add("loading");
              },
              { passive: true }
            );
            player.addEventListener(
              "error",
              function () {
                var card = player.__currentCard;
                if (card) {
                  card.classList.remove("loading", "playing");
                  card.classList.add("error");
                }
              },
              { passive: true }
            );
          }

          function ensureAnalyser() {
            try {
              if (!window.__waveAnalyser && player) {
                var AC = window.AudioContext || window.webkitAudioContext;
                var ctx = new AC();
                var srcNode = ctx.createMediaElementSource(player);
                var analyser = ctx.createAnalyser();
                analyser.fftSize = 1024;
                srcNode.connect(analyser);
                analyser.connect(ctx.destination);
                window.__waveAnalyser = analyser;
              }
            } catch (_) {}
          }

          function playTrackSrc(src, card) {
            if (!player) return;
            var same = player.src && player.src.endsWith(src);
            if (same && !player.paused) {
              player.pause();
              if (window.__stopWave) window.__stopWave();
              bodies.forEach(function (b) {
                b.el.classList.remove("playing", "loading", "error");
              });
              player.__currentCard = null;
              return;
            }
            if (typeof window.__primeAudio === "function")
              window.__primeAudio();
            if (!same) {
              player.src = src;
              player.load();
            }
            player.__currentCard = card || null;

            // pick a stable accent color by the card's index (fallback cyan)
            var idx = 0;
            if (card) {
              var label = (card.__bodyRef && card.__bodyRef.label) || "";
              var m = /card-(\d+)/.exec(label);
              if (m) idx = +m[1] % ACCENTS.length;
            }
            var acc = ACCENTS[idx] || "#7dd3fc";
            // morph line follows the track’s accent
            document.documentElement.style.setProperty(
              "--morph-stroke-color",
              acc
            );
            if (card) card.style.setProperty("--accent", acc);
            ensureAnalyser();
            bodies.forEach(function (b) {
              b.el.classList.remove("playing", "loading", "error");
            });
            if (card) {
              card.classList.remove("error");
              card.classList.add("loading");
            }
            if (card && window.__startWaveOn) window.__startWaveOn(card);
            var p = player.play();
            if (p && typeof p.catch === "function")
              p.catch(function (err) {
                console.warn("[audio] play interrupted", err);
              });
          }

          function buildWorld() {
            engine = Engine.create({ enableSleeping: true });
            // Tighten solver to reduce interpenetration
            try {
              engine.positionIterations = 6;
              engine.velocityIterations = 4;
              engine.constraintIterations = 2;
            } catch (_) {}
            engine.gravity.y = 0; // we drive motion with gentle impulses + scroll

            // Full-viewport bounds (thicker, slightly inset, bouncy walls)
            function makeWalls() {
              const W = window.innerWidth;
              const H = window.innerHeight;

              // Wall thickness scales with screen size so bodies can’t tunnel through.
              const T = Math.max(
                140,
                Math.min(240, Math.round(Math.min(W, H) * 0.08))
              );

              // Tiny inset so we’re inside the rendered edge (avoids sub-pixel leaks).
              const INSET = 18; // slightly more inset so clicks near edges don't get eaten

              const WALL = {
                isStatic: true,
                restitution: 0.92, // lively bounce
                friction: 0, // don’t “stick” to walls
                frictionStatic: 0,
                frictionAir: 0,
                slop: 0.02, // low overlap tolerance so they never visibly cross
                render: { visible: false },
              };

              const top = Bodies.rectangle(
                W / 2,
                INSET - T / 2,
                W + T * 2,
                T,
                WALL
              );
              const bottom = Bodies.rectangle(
                W / 2,
                H - INSET + T / 2,
                W + T * 2,
                T,
                WALL
              );
              const left = Bodies.rectangle(
                INSET - T / 2,
                H / 2,
                T,
                H + T * 2,
                WALL
              );
              const right = Bodies.rectangle(
                W - INSET + T / 2,
                H / 2,
                T,
                H + T * 2,
                WALL
              );

              [top, bottom, left, right].forEach((w) => {
                w.label = "wall";
                Composite.add(engine.world, w);
              });
            }
            makeWalls();

            // Build bodies out of the six service cards
            var cards = [].slice.call(
              document.querySelectorAll(
                "#services .services-grid .service-card"
              )
            );
            if (!cards.length) return;
            __originalCards = cards.slice();
            __grid = document.querySelector("#services .services-grid");

            var snaps = cards.map(function (card) {
              var r = card.getBoundingClientRect();
              // document-space coordinates (robust against scroll state)
              var docX = r.left + window.scrollX + r.width / 2;
              var docY = r.top + window.scrollY + r.height / 2;
              return {
                card: card,
                docX: docX,
                docY: docY,
                w: r.width,
                h: r.height,
              };
            });

            // Overlay visibility via CSS (.float-on /.party)

            var isCoarse =
              (window.matchMedia &&
                window.matchMedia("(pointer: coarse)").matches) ||
              "ontouchstart" in window;

            bodies = [];
            var cx = innerWidth / 2,
              cy = innerHeight / 2;
            snaps.forEach(function (snap, i) {
              var el = snap.card;

              // 5) Seed a randomized rotation angle variable if not already present
              var initA = Math.random() * Math.PI * 2;

              // Move into overlay and stylize
              layer.appendChild(el);
              el.classList.add("flying-card", "swap-on");
              el.style.position = "absolute";
              el.style.pointerEvents = "auto";
              el.style.background = BASES[i % BASES.length];
              el.style.color = "#fff";
              // Don’t allow drag/click until the launch shrink is over
              el.classList.add("no-drag");
              el.style.pointerEvents = "none";
              // Hardening for float/flick/tap (prevents text selection and tap highlights)
              el.style.willChange = "transform";
              el.style.userSelect = "none";
              el.style.webkitUserSelect = "none";
              el.style.webkitUserDrag = "none";
              el.style.webkitTapHighlightColor = "transparent";

              // Stage visual continuity: start at the service card's on-page position
              // and its original size, then shrink to the float size with a soft pulse.
              var origW = Math.round(snap.w);
              var origH = Math.round(snap.h);
              el.style.width = origW + "px";
              el.style.height = origH + "px";
              el.style.transformOrigin = "center center";

              // Compute start position in viewport coords (center of original card)
              var startX = 0,
                startY = 0; // temp placeholders; real values set below

              // Centered title only
              var swap = el.querySelector(".title-swap");
              if (!swap) {
                swap = document.createElement("div");
                swap.className = "title-swap";
                el.appendChild(swap);
              }
              swap.textContent = TITLES[i % TITLES.length];
              var h3 = el.querySelector("h3");
              if (h3) {
                var fs = getComputedStyle(h3).fontSize;
                var lh = getComputedStyle(h3).lineHeight;
                swap.style.fontSize = fs;
                if (lh && lh !== "normal") swap.style.lineHeight = lh;
              }
              el.querySelectorAll("h3,p").forEach(function (n) {
                n.style.display = "none";
              });

              // 4) Click/Touch to play (capture; ignore if currently dragging this body)
              (function (trackSrc, cardEl) {
                cardEl.__track = trackSrc;
                cardEl.addEventListener(
                  "click",
                  function (ev) {
                    ev.stopPropagation();
                    // ignore click if Matter thinks we're dragging this body
                    if (
                      window.__draggingBodies &&
                      cardEl.__bodyRef &&
                      window.__draggingBodies.has(cardEl.__bodyRef)
                    ) {
                      return;
                    }
                    // If pointer moved just before up, treat it as drag, not click
                    if (
                      typeof recentPts !== "undefined" &&
                      recentPts.length >= 2
                    ) {
                      var a = recentPts[0];
                      var z = recentPts[recentPts.length - 1];
                      var moved2 =
                        (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
                      if (moved2 > 10 * 10) return; // >10px → don’t trigger play
                    }
                    // Root captures; children are pointer-events:none — no extra hit test needed
                    playTrackSrc(cardEl.__track, cardEl);
                  },
                  true
                ); // <-- capture = true so the card gets the click first

                // iOS: gesture-qualified play on touchend (capture)
                cardEl.addEventListener(
                  "touchend",
                  function (ev) {
                    // if we were kinematic dragging, don't treat as play
                    if (cardEl.__bodyRef && cardEl.__bodyRef.__kinDrag) return;
                    // unlock audio context if needed
                    if (typeof window.__primeAudio === "function")
                      window.__primeAudio();
                    // movement threshold via recentPts
                    if (
                      typeof recentPts !== "undefined" &&
                      recentPts.length >= 2
                    ) {
                      var a = recentPts[0];
                      var z = recentPts[recentPts.length - 1];
                      var moved2 =
                        (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
                      if (moved2 > 10 * 10) return;
                    }
                    // This is a qualified tap → prevent synthetic click and remember
                    try {
                      ev.preventDefault();
                    } catch (_) {}
                    window.__lastTouchPlayAt = performance.now();
                    playTrackSrc(cardEl.__track, cardEl);
                  },
                  true
                );
              })(TRACKS[i % TRACKS.length], el);

              el.style.touchAction = "none"; // keep this for reliable touch dragging

              // Project document coords into the current viewport so we never all spawn from left
              var viewX = snap.docX - window.scrollX;
              var viewY = snap.docY - window.scrollY;

              // If the Services section is off-screen, fall back to a visible on-screen seed near center
              var inViewX = viewX >= 0 && viewX <= innerWidth;
              var inViewY = viewY >= 0 && viewY <= innerHeight;

              var jitter = 20; // slight randomization so they don't overlap
              var startX, startY;

              if (inViewX && inViewY) {
                startX = viewX + (Math.random() * jitter - jitter / 2);
                startY = viewY + (Math.random() * jitter - jitter / 2);
              } else {
                // seed around center so they never come from off-stage
                startX = innerWidth * (0.45 + Math.random() * 0.1);
                startY = innerHeight * (0.45 + Math.random() * 0.1);
              }

              // Clamp into live area so the first paint is always visible
              var pad = 40;
              startX = Math.max(pad, Math.min(innerWidth - pad, startX));
              startY = Math.max(pad, Math.min(innerHeight - pad, startY));

              // Paint the card exactly over its old spot (transform-only),
              // then we animate the shrink. Keep initial random rotation.
              el.style.transform =
                "translate3d(" +
                (startX - origW / 2).toFixed(1) +
                "px," +
                (startY - origH / 2).toFixed(1) +
                "px,0) rotate(" +
                initA.toFixed(3) +
                "rad)";
              // Freeze the first paint so it doesn't flash at (0,0)
              el.offsetHeight; // force layout

              // Decide float size (mobile = thumb; desktop = 50%) and animate the shrink
              var W = snap.w,
                H = snap.h;
              if (isCoarse) {
                var TW = Math.max(
                  88,
                  Math.min(120, Math.round(innerWidth * 0.22))
                );
                W = H = TW;
              } else {
                W = Math.round(snap.w * 0.5);
                H = Math.round(snap.h * 0.5);
              }

              // Smoothly shrink from original size to float size
              el.style.willChange = "transform,width,height";
              el.classList.add("launching");
              requestAnimationFrame(function () {
                el.style.width = W + "px";
                el.style.height = H + "px";
                // End of launch: re-enable input and sync physics size
                setTimeout(function () {
                  el.classList.remove("launching");
                  el.classList.remove("no-drag");
                  el.style.pointerEvents = "auto"; // drag & click now reliable
                  // Sync physics size to the final DOM size after the shrink
                  try {
                    var cx = body.position.x,
                      cy = body.position.y;
                    Matter.Body.setPosition(body, { x: cx, y: cy });
                    Matter.Body.setVertices(
                      body,
                      Matter.Vertices.fromPath(
                        "0 0 " + W + " 0 " + W + " " + H + " 0 " + H
                      )
                    );
                    Matter.Body.setInertia(
                      body,
                      (body.mass * Math.max(W, H) * Math.max(W, H)) / 12
                    );
                  } catch (_) {}
                }, 420);
              });

              // 3) Create body at original size so picking matches DOM during launch
              var body = Bodies.rectangle(startX, startY, origW, origH, {
                restitution: isCoarse ? 0.7 + Math.random() * 0.15 : 0.6,
                frictionAir: isCoarse
                  ? 0.012 + Math.random() * 0.008
                  : 0.004 + Math.random() * 0.003,
                friction: isCoarse ? 0 : 0.001,
                slop: 0.02,
                density: 0.0008,
                // inertia: Infinity, // REMOVED
                chamfer: { radius: 12 },
                angle: initA,
              });
              body.__idle = {
                // leaf-on-water: slower frequencies + stronger micro-forces
                ax:
                  (0.00042 + Math.random() * 0.00028) * (isCoarse ? 1.2 : 1.0), // x force amplitude
                ay:
                  (0.00042 + Math.random() * 0.00028) * (isCoarse ? 1.2 : 1.0), // y force amplitude
                fx: 0.06 + Math.random() * 0.12, // x frequency (very slow)
                fy: 0.06 + Math.random() * 0.12, // y frequency (very slow)
                px: Math.random() * Math.PI * 2, // x phase
                py: Math.random() * Math.PI * 2, // y phase
                t0: Math.random() * 10.0, // per-card time offset so waves are de-synced
              };
              body.label = "card-" + i;
              Composite.add(engine.world, body);
              bodies.push({ el: el, body: body, w: W, h: H });
              // 4) After pushing to bodies, add cross refs for drag detection
              el.__bodyRef = body;
              body.__el = el;

              // Softer randomized start so each card begins independently
              var baseV = isCoarse ? 1.2 : 0.9;
              Matter.Body.setVelocity(body, {
                x: (Math.random() - 0.5) * baseV,
                y: (Math.random() - 0.5) * baseV,
              });
              body.angularVelocity = (Math.random() - 0.5) * 1.2;

              // --- Mobile long-press → kinematic drag (pick-and-move) ---
              (function (cardEl, bd) {
                if (!isCoarse) return; // touch-only behavior
                var pressTimer = null,
                  startX = 0,
                  startY = 0,
                  moved = false,
                  dragging = false; // movement gate
                function clearTimer() {
                  if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                  }
                }
                function beginDrag() {
                  dragging = true;
                  bd.__kinDrag = true;
                  bd.__lastGoodX = bd.position.x;
                  bd.__lastGoodY = bd.position.y;
                  window.__draggingBodies && window.__draggingBodies.add(bd);
                }
                function endDrag() {
                  if (!dragging) return;
                  dragging = false;
                  bd.__kinDrag = false;
                  window.__draggingBodies && window.__draggingBodies.delete(bd);
                  // fling from recentPts
                  if (recentPts.length >= 2) {
                    var a = recentPts[0],
                      z = recentPts[recentPts.length - 1];
                    var dt = (z.t - a.t) / 1000;
                    if (dt > 0) {
                      var vx = (z.x - a.x) / dt,
                        vy = (z.y - a.y) / dt;
                      var CL = 1200;
                      vx = Math.max(-CL, Math.min(CL, vx));
                      vy = Math.max(-CL, Math.min(CL, vy));
                      Matter.Body.setVelocity(bd, { x: vx / 60, y: vy / 60 });
                      bd.angularVelocity += (Math.random() - 0.5) * 0.6;
                    }
                  }
                  recentPts.length = 0;
                }
                cardEl.addEventListener(
                  "touchstart",
                  function (e) {
                    if (!e.touches || !e.touches[0]) return;
                    moved = false;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    clearTimer();
                    pressTimer = setTimeout(function () {
                      if (!moved) {
                        beginDrag();
                      }
                    }, 220);
                  },
                  { passive: true, capture: true }
                );
                cardEl.addEventListener(
                  "touchmove",
                  function (e) {
                    if (!e.touches || !e.touches[0]) return;
                    var x = e.touches[0].clientX,
                      y = e.touches[0].clientY;
                    var dx = x - startX,
                      dy = y - startY;
                    if (dx * dx + dy * dy > 100) {
                      moved = true;
                    }
                    if (dragging) {
                      pushPointer(x, y);
                      bd.__kinX = x;
                      bd.__kinY = y;
                    }
                  },
                  { passive: true }
                );
                cardEl.addEventListener(
                  "touchend",
                  function () {
                    clearTimer();
                    if (dragging) endDrag();
                  },
                  { passive: true, capture: true }
                );
              })(el, body);
            });
            // NEW: bind to document so overlay never eats scroll
            var mouse = Mouse.create(document.body);
            mouse.pixelRatio = window.devicePixelRatio || 1;

            var mc = MouseConstraint.create(engine, {
              mouse,
              constraint: {
                stiffness: 0.14, // gentler, less "sticky"
                damping: 0.22,
                angularStiffness: 0, // allow free rotation while held
                render: { visible: false },
              },
            });
            Composite.add(engine.world, mc);
            // Force headless coordinates to be viewport-based (ignore element offsets)
            try {
              mc.mouse.offset.x = 0;
              mc.mouse.offset.y = 0;
              mc.mouse.scale.x = 1;
              mc.mouse.scale.y = 1;
            } catch (_) {}

            // Make a bit stickier on fine pointers
            var finePointer =
              window.matchMedia && window.matchMedia("(pointer: fine)").matches;
            if (finePointer && mc.constraint) {
              mc.constraint.stiffness = 0.22;
              mc.constraint.angularStiffness = 0;
            }
            // Allow taps + drags without blocking scroll
            if (mc.mouse && mc.mouse.element) {
              mc.mouse.element.style.touchAction = "pan-y"; // allow vertical scroll on wheel/touchpads
            }

            // Track dragging bodies so clicks during a drag don't trigger play()
            var dragging = new Set();
            window.__draggingBodies = dragging;

            // --- Recent-pointer velocity sampler for fling throws ---
            var recentPts = []; // [{x,y,t}, ...] ~140ms window
            var MAX_AGE_MS = 140;
            function pushPointer(x, y) {
              var now = performance.now();
              recentPts.push({ x: x, y: y, t: now });
              while (recentPts.length && now - recentPts[0].t > MAX_AGE_MS) {
                recentPts.shift();
              }
            }

            // Feed the sampler *only while dragging*
            var __onMouseMove = function (e) {
              // Keep Matter's mouse in viewport coordinates so picking works at any scrollY
              mc.mouse.position.x = e.clientX;
              mc.mouse.position.y = e.clientY;
              if (mc.body) pushPointer(e.clientX, e.clientY);
            };
            var __onTouchMove = function (e) {
              if (e.touches && e.touches[0]) {
                var x = e.touches[0].clientX,
                  y = e.touches[0].clientY;
                mc.mouse.position.x = x;
                mc.mouse.position.y = y;
                if (mc.body) pushPointer(x, y);
              }
            };
            window.addEventListener("mousemove", __onMouseMove, {
              passive: true,
            });
            window.addEventListener("touchmove", __onTouchMove, {
              passive: true,
            });
            __cleanup.push(function () {
              window.removeEventListener("mousemove", __onMouseMove);
              window.removeEventListener("touchmove", __onTouchMove);
            });

            // Track the most recent down event for tap-vs-drag decisions
            var __lastDown = { t: 0, x: 0, y: 0 };
            document.addEventListener(
              "mousedown",
              function (e) {
                __lastDown.t = performance.now();
                __lastDown.x = e.clientX;
                __lastDown.y = e.clientY;
              },
              true
            );
            document.addEventListener(
              "touchstart",
              function (e) {
                if (e.touches && e.touches[0]) {
                  __lastDown.t = performance.now();
                  __lastDown.x = e.touches[0].clientX;
                  __lastDown.y = e.touches[0].clientY;
                }
              },
              { passive: true, capture: true }
            );

            // Capture clicks anywhere on the page and dispatch to the topmost flying-card under the pointer.
            // This ensures click-to-play works even when the overlay itself is not the event target (e.g., near the hero/nav).
            function cardMetaAt(x, y) {
              for (var i = bodies.length - 1; i >= 0; i--) {
                var el = bodies[i].el;
                var r = el.getBoundingClientRect();
                if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom)
                  return bodies[i];
              }
              return null;
            }
            var __onDocClick = function (ev) {
              // Only when floating
              var html = document.documentElement;
              if (
                !(
                  html.classList.contains("party") ||
                  html.classList.contains("float-on")
                )
              )
                return;
              var x = ev.clientX,
                y = ev.clientY;
              if (typeof x !== "number" || typeof y !== "number") return;
              // If the topmost element is nav or not a flying card, don't hijack the click
              var topEl = document.elementFromPoint(x, y);
              if (topEl) {
                if (topEl.closest && topEl.closest("#nav")) return;
                if (!(topEl.closest && topEl.closest(".flying-card"))) return;
              }
              // ignore if a drag just occurred or distance/time exceeds tap thresholds
              var moved2 = Infinity;
              if (typeof recentPts !== "undefined" && recentPts.length >= 2) {
                var a = recentPts[0],
                  z = recentPts[recentPts.length - 1];
                moved2 = (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
              } else if (typeof __lastDown !== "undefined" && __lastDown.t) {
                var dx = x - __lastDown.x,
                  dy = y - __lastDown.y;
                moved2 = dx * dx + dy * dy;
              }
              var dtTap =
                typeof __lastDown !== "undefined" && __lastDown.t
                  ? performance.now() - __lastDown.t
                  : 0;
              // Treat tiny drags (<10px and <320ms) as taps; otherwise, suppress play
              if (!(moved2 <= 10 * 10 && dtTap <= 320)) return;
              var meta = cardMetaAt(x, y);
              if (!meta) return;
              // Prevent underlying links from firing when we intent to play
              ev.stopPropagation();
              // Gesture-qualified play path (click)
              if (meta && meta.el && meta.el.__track) {
                playTrackSrc(meta.el.__track, meta.el);
              }
            };
            document.addEventListener("click", __onDocClick, true);
            __cleanup.push(function () {
              document.removeEventListener("click", __onDocClick, true);
            });

            // Start/End drag hooks
            Events.on(mc, "startdrag", function (e) {
              if (e && e.body) {
                dragging.add(e.body);
                // wake up just in case
                if (Matter.Sleeping && Matter.Sleeping.set) {
                  Matter.Sleeping.set(e.body, false);
                }
                // Stick under pointer: stop motion immediately and stiffen grip slightly
                try {
                  Matter.Body.setVelocity(e.body, { x: 0, y: 0 });
                  e.body.angularVelocity = 0;
                } catch (_) {}
                if (mc && mc.constraint) {
                  mc.constraint.__prevStiff = mc.constraint.stiffness;
                  mc.constraint.stiffness = Math.max(
                    mc.constraint.stiffness,
                    0.35
                  );
                }
                // Brief glow flash on held
                try {
                  var __el = e.body.__el;
                  if (__el) {
                    __el.classList.add("held");
                    if (__el.__heldTimer) {
                      clearTimeout(__el.__heldTimer);
                    }
                    __el.__heldTimer = setTimeout(function () {
                      __el.classList.remove("held");
                      __el.__heldTimer = null;
                    }, 500);
                  }
                } catch (_) {}
              }
              recentPts.length = 0; // fresh sample window
            });

            Events.on(mc, "enddrag", function (e) {
              var b = e && e.body;
              if (!b) return;
              dragging.delete(b);
              if (
                mc &&
                mc.constraint &&
                typeof mc.constraint.__prevStiff === "number"
              ) {
                mc.constraint.stiffness = mc.constraint.__prevStiff;
                mc.constraint.__prevStiff = undefined;
              }

              // Compute fling velocity from the sample window
              if (recentPts.length >= 2) {
                var a = recentPts[0];
                var z = recentPts[recentPts.length - 1];
                var dt = (z.t - a.t) / 1000; // sec
                if (dt > 0) {
                  var vx = (z.x - a.x) / dt; // px/s
                  var vy = (z.y - a.y) / dt; // px/s

                  // clamp and convert to Matter units (approx px/frame at 60fps)
                  var CLAMP = 1200;
                  vx = Math.max(-CLAMP, Math.min(CLAMP, vx));
                  vy = Math.max(-CLAMP, Math.min(CLAMP, vy));
                  Matter.Body.setVelocity(b, { x: vx / 60, y: vy / 60 });

                  // give it a little spin on release
                  b.angularVelocity += (Math.random() - 0.5) * 0.7;
                }
              }
              recentPts.length = 0;
            });

            // Scroll impulse → push cards in scroll direction
            var lastY = window.scrollY;
            var __onScroll = function () {
              var dy = window.scrollY - lastY;
              lastY = window.scrollY;
              if (!dy) return;
              var mag = Math.min(40, Math.abs(dy) * 0.6);
              var signY = dy > 0 ? 1 : -1;
              bodies.forEach(function (b) {
                var bx = b.body.position.x,
                  by = b.body.position.y;
                var fx = (Math.random() - 0.5) * 0.02 * mag * 1e-3;
                var fy = signY * 0.025 * mag * 1e-3;
                Matter.Body.applyForce(
                  b.body,
                  { x: bx, y: by },
                  { x: fx, y: fy }
                );
                b.body.angularVelocity +=
                  (Math.random() - 0.5) * 0.04 * (mag / 12);
              });
              jostle(260, Math.min(2.4, 0.6 + mag / 18));
            };
            addEventListener("scroll", __onScroll, { passive: true });
            __cleanup.push(function () {
              removeEventListener("scroll", __onScroll);
            });

            // Desktop wheel adds extra oomph (high-res delta)
            var __lastWheelJostle = 0;
            var __onWheel = function (e) {
              var dy = e.deltaY || 0;
              if (!dy) return;
              var now = performance.now();
              if (now - __lastWheelJostle < 120) return; // throttle
              __lastWheelJostle = now;
              var mag = Math.min(48, Math.abs(dy) * 0.28);
              var signY = dy > 0 ? 1 : -1;
              bodies.forEach(function (b) {
                var fx = (Math.random() - 0.5) * 0.03 * mag * 1e-3;
                var fy = signY * 0.03 * mag * 1e-3;
                Matter.Body.applyForce(b.body, b.body.position, {
                  x: fx,
                  y: fy,
                });
                b.body.angularVelocity +=
                  (Math.random() - 0.5) * 0.05 * (mag / 18);
              });
              jostle(300, Math.min(3, 0.8 + mag / 20));
            };
            addEventListener("wheel", __onWheel, { passive: true });
            __cleanup.push(function () {
              removeEventListener("wheel", __onWheel);
            });

            // Touch drag = jostle as you scroll with your finger
            var __lastJostle = 0;
            var __onTouchScroll = function (e) {
              var touches = e.touches;
              if (!touches || !touches[0]) return;
              var now = performance.now();
              if (now - __lastJostle < 180) return; // throttle
              __lastJostle = now;
              jostle(180, 1.0);
            };
            addEventListener("touchmove", __onTouchScroll, { passive: true });
            __cleanup.push(function () {
              removeEventListener("touchmove", __onTouchScroll);
            });

            // Headless render: copy body transforms to DOM
            function render() {
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i];
                var x = b.body.position.x - b.w / 2;
                var y = b.body.position.y - b.h / 2;
                var a = b.body.angle;
                var t =
                  "translate3d(" +
                  x.toFixed(1) +
                  "px," +
                  y.toFixed(1) +
                  "px,0) rotate(" +
                  a.toFixed(3) +
                  "rad)";
                b.el.style.transform = t;
              }
            }

            // Resize walls on viewport resize
            var onResize = function () {
              // remove old walls
              Composite.allBodies(engine.world)
                .filter((b) => b.label === "wall")
                .forEach((w) => Composite.remove(engine.world, w));

              // rebuild with the current viewport size/thickness rules
              makeWalls();
            };
            addEventListener("resize", onResize);
            __cleanup.push(function () {
              removeEventListener("resize", onResize);
            });

            // Replace Runner with a single RAF driving both physics and render
            var __last = performance.now();
            function tick(t) {
              var dt = Math.min(1000 / 30, t - __last); // cap dt to 33ms for stability
              __last = t;
              try {
                Engine.update(engine, dt);
              } catch (_) {}
              render();
              requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);

            // Perpetual wander: each card has a heading vector that slowly
            // drifts. We push along heading + tiny noise so motion feels
            // one-directional and natural.
            Events.on(engine, "beforeUpdate", function (ev) {
              var dt = (ev.delta || 1000 / 60) / 1000; // seconds
              __idleT += dt;
              var TAU = Math.PI * 2;
              for (var i = 0; i < bodies.length; i++) {
                var bd = bodies[i].body;
                // Kinematic drag: follow finger when active (touch-only path)
                if (
                  bd.__kinDrag &&
                  typeof bd.__kinX === "number" &&
                  typeof bd.__kinY === "number"
                ) {
                  var tx = bd.__kinX,
                    ty = bd.__kinY;
                  // Find meta (size) for this body
                  var metaSelf = null;
                  for (var mi = 0; mi < bodies.length; mi++) {
                    if (bodies[mi].body === bd) {
                      metaSelf = bodies[mi];
                      break;
                    }
                  }
                  if (metaSelf) {
                    var hw = metaSelf.w * 0.5,
                      hh = metaSelf.h * 0.5;
                    var pad = 18; // keep off exact edges
                    tx = Math.max(
                      pad + hw,
                      Math.min(innerWidth - pad - hw, tx)
                    );
                    ty = Math.max(
                      pad + hh,
                      Math.min(innerHeight - pad - hh, ty)
                    );
                    // Block overlaps with other cards using simple AABB test
                    var blocked = false;
                    for (var mj = 0; mj < bodies.length; mj++) {
                      var other = bodies[mj];
                      if (other.body === bd) continue;
                      var ox = other.body.position.x,
                        oy = other.body.position.y;
                      var ohw = other.w * 0.5,
                        ohh = other.h * 0.5;
                      if (
                        tx + hw > ox - ohw &&
                        tx - hw < ox + ohw &&
                        ty + hh > oy - ohh &&
                        ty - hh < oy + ohh
                      ) {
                        blocked = true;
                        break;
                      }
                    }
                    if (!blocked) {
                      Matter.Body.setPosition(bd, { x: tx, y: ty });
                      bd.__lastGoodX = tx;
                      bd.__lastGoodY = ty;
                    } else if (typeof bd.__lastGoodX === "number") {
                      Matter.Body.setPosition(bd, {
                        x: bd.__lastGoodX,
                        y: bd.__lastGoodY,
                      });
                    }
                  } else {
                    Matter.Body.setPosition(bd, { x: tx, y: ty });
                  }
                }
                // Angular damping (approx) for mobile for a smoother settle
                if (isCoarse && bd.angularVelocity) {
                  var damp = 0.08; // ~0.06–0.1
                  bd.angularVelocity *= Math.max(0, 1 - damp * dt);
                }
                if (!bd.__wander) {
                  // heading angle, speed scalar, and a timer for small course changes
                  bd.__wander = {
                    ang: Math.random() * Math.PI * 2,
                    speed: 0.00042 + Math.random() * 0.00038,
                    turnTimer: 0.8 + Math.random() * 1.4,
                  };
                }
                var w = bd.__wander;
                // occasionally perturb heading a little so paths diverge
                w.turnTimer -= dt;
                if (w.turnTimer <= 0) {
                  w.ang += (Math.random() - 0.5) * 0.6; // small course change
                  w.speed = Math.max(
                    0.00025,
                    Math.min(0.0009, w.speed + (Math.random() - 0.5) * 0.00025)
                  );
                  w.turnTimer = 0.8 + Math.random() * 1.6;
                }
                var fx =
                  Math.cos(w.ang) * w.speed + (Math.random() - 0.5) * 0.00002;
                var fy =
                  Math.sin(w.ang) * w.speed + (Math.random() - 0.5) * 0.00002;
                Matter.Body.applyForce(bd, bd.position, { x: fx, y: fy });
                // Slight continuous spin, gentler than before
                var targetSpin = 0.012 * (Math.random() > 0.5 ? 1 : -1);
                if (Math.abs(bd.angularVelocity) < 0.04) {
                  bd.angularVelocity += targetSpin * dt;
                }
                // Independent idle drift (per-card seeds + per-card time offset)
                if (bd.__idle) {
                  var s = bd.__idle;
                  var localT = __idleT + (s.t0 || 0); // de-sync timelines per card
                  // --- soft containment / wrap-back ---
                  var Wv = innerWidth,
                    Hv = innerHeight;
                  var pad = 40; // live area inset
                  var kEdge = 0.0005; // gentle pull
                  var kWrap = 0.9; // reduce velocity if teleported

                  var px = bd.position.x,
                    py = bd.position.y;
                  if (px < pad) {
                    Matter.Body.applyForce(bd, bd.position, { x: kEdge, y: 0 });
                  } else if (px > Wv - pad) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -kEdge,
                      y: 0,
                    });
                  }
                  if (py < pad) {
                    Matter.Body.applyForce(bd, bd.position, { x: 0, y: kEdge });
                  } else if (py > Hv - pad) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0,
                      y: -kEdge,
                    });
                  }

                  // emergency wrap (if somehow far outside)
                  var out = 200;
                  if (
                    px < -out ||
                    px > Wv + out ||
                    py < -out ||
                    py > Hv + out
                  ) {
                    Matter.Body.setPosition(bd, {
                      x: Math.min(Math.max(pad, px), Wv - pad),
                      y: Math.min(Math.max(pad, py), Hv - pad),
                    });
                    Matter.Body.setVelocity(bd, {
                      x: bd.velocity.x * kWrap,
                      y: bd.velocity.y * kWrap,
                    });
                  }

                  // --- anti-corner nudge: if near a corner, push diagonally back in ---
                  var near = 42; // corner proximity threshold
                  var vx = bd.velocity.x,
                    vy = bd.velocity.y;
                  // top-left
                  if (px < pad + near && py < pad + near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0.0012,
                      y: 0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x += 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y += 0.3;
                  }
                  // top-right
                  else if (px > Wv - pad - near && py < pad + near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -0.0012,
                      y: 0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x -= 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y += 0.3;
                  }
                  // bottom-left
                  else if (px < pad + near && py > Hv - pad - near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0.0012,
                      y: -0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x += 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y -= 0.3;
                  }
                  // bottom-right
                  else if (px > Wv - pad - near && py > Hv - pad - near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -0.0012,
                      y: -0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x -= 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y -= 0.3;
                  }

                  // sinusoidal micro-forces with unique freq & phase per axis
                  var fxIdle = Math.sin(TAU * s.fx * localT + s.px) * s.ax;
                  var fyIdle = Math.sin(TAU * s.fy * localT + s.py) * s.ay;

                  Matter.Body.applyForce(bd, bd.position, {
                    x: fxIdle,
                    y: fyIdle,
                  });

                  // ambient vector field (very gentle, position + time dependent)
                  var vfx =
                    Math.sin(bd.position.y * 0.002 + __idleT * 0.15) * 0.00008;
                  var vfy =
                    Math.cos(bd.position.x * 0.002 - __idleT * 0.12) * 0.00008;
                  Matter.Body.applyForce(bd, bd.position, { x: vfx, y: vfy });

                  // tiny continuous orientation wander so cards gently rotate even at rest
                  var rotNudge =
                    Math.sin(TAU * (s.fx * 0.42) * localT + s.px * 0.37) *
                    0.00003;
                  bd.torque += rotNudge;
                  // ensure a tiny baseline drift so nothing fully stalls
                  var baseDrift = 0.00005;
                  Matter.Body.applyForce(bd, bd.position, {
                    x: (Math.random() - 0.5) * baseDrift,
                    y: (Math.random() - 0.5) * baseDrift,
                  });
                  // gently wake if velocity is extremely low
                  var v2 =
                    bd.velocity.x * bd.velocity.x +
                    bd.velocity.y * bd.velocity.y;
                  if (v2 < 0.00002) {
                    if (Matter.Sleeping && Matter.Sleeping.set)
                      Matter.Sleeping.set(bd, false);
                    bd.velocity.x += (Math.random() - 0.5) * 0.16;
                    bd.velocity.y += (Math.random() - 0.5) * 0.16;
                    bd.angularVelocity += (Math.random() - 0.5) * 0.035;
                  }
                }
              }
            });

            // Cursor/Finger magnet: sticky, local attraction only when hovering a card
            (function () {
              var mx = 0,
                my = 0,
                hasMouse = false,
                tx = 0,
                ty = 0,
                hasTouch = false;
              document.addEventListener(
                "mousemove",
                function (e) {
                  mx = e.clientX;
                  my = e.clientY;
                  hasMouse = true;
                },
                { passive: true }
              );
              document.addEventListener(
                "touchmove",
                function (e) {
                  if (!e.touches || !e.touches[0]) return;
                  tx = e.touches[0].clientX;
                  ty = e.touches[0].clientY;
                  hasTouch = true;
                },
                { passive: true }
              );

              function metaForBody(bd) {
                for (var i = 0; i < bodies.length; i++) {
                  if (bodies[i].body === bd) return bodies[i];
                }
                return null;
              }

              Events.on(engine, "afterUpdate", function () {
                if (!(hasMouse || hasTouch) || !bodies.length) return;

                // find nearest card center
                var nearest = null,
                  bestD2 = Infinity;
                for (var i = 0; i < bodies.length; i++) {
                  var bd = bodies[i].body;
                  var hx = hasTouch ? tx : mx;
                  var hy = hasTouch ? ty : my;
                  var dx = hx - bd.position.x;
                  var dy = hy - bd.position.y;
                  var d2 = dx * dx + dy * dy;
                  if (d2 < bestD2) {
                    bestD2 = d2;
                    nearest = bd;
                  }
                }
                if (!nearest) return;

                var meta = metaForBody(nearest);
                if (!meta) return;

                // Only attract when cursor is essentially "hovering" the card:
                // use a radius equal to ~the card size (half the diagonal).
                var halfDiag =
                  0.5 * Math.sqrt(meta.w * meta.w + meta.h * meta.h);
                var radius = Math.max(halfDiag * 0.9, 60); // sticky only when close
                if (bestD2 > radius * radius) return;

                // Small pull so it feels sticky, not grabby
                var d = Math.sqrt(bestD2);
                var pull = 0.000035 * (1 - d / radius); // weaker and very local
                var hx = hasTouch ? tx : mx;
                var hy = hasTouch ? ty : my;
                var fx = (hx - nearest.position.x) * pull;
                var fy = (hy - nearest.position.y) * pull;
                Matter.Body.applyForce(nearest, nearest.position, {
                  x: fx,
                  y: fy,
                });
              });
            })();

            // Impacts add spin; also free inertia after first bounce for natural rotation
            Events.on(engine, "collisionStart", function (evt) {
              var pairs = evt.pairs || [];
              for (var i = 0; i < pairs.length; i++) {
                var a = pairs[i].bodyA,
                  b = pairs[i].bodyB;

                [a, b].forEach(function (body) {
                  if (body.label && String(body.label).indexOf("card-") === 0) {
                    if (body.inertia === Infinity) {
                      // allow rotation after first hit
                      Matter.Body.setInertia(
                        body,
                        (body.mass *
                          Math.max(40, body.bounds.max.x - body.bounds.min.x) **
                            2) /
                          12
                      );
                    }
                    body.angularVelocity += (Math.random() - 0.5) * 0.07; // subtler spin-on-impact
                  }
                });
              }
            });
          }

          // Maintain original grid + cards, listeners, and teardown
          var __originalCards = [];
          var __grid = null;
          var __cleanup = [];

          function start() {
            if (ACTIVE) return;
            ACTIVE = true;
            document.documentElement.classList.add("float-on");
            buildWorld();
          }

          function stop() {
            if (!ACTIVE) return;
            ACTIVE = false;
            document.documentElement.classList.remove("float-on");

            // Cancel RAF for headless render
            if (ticking) {
              cancelAnimationFrame(ticking);
              ticking = 0;
            }

            // Remove event listeners registered during build
            try {
              for (var i = 0; i < __cleanup.length; i++) __cleanup[i]();
            } catch (_) {}
            __cleanup.length = 0;

            // Stop Matter engine/runner
            try {
              if (runner) Matter.Runner.stop(runner);
            } catch (_) {}
            runner = null;
            try {
              if (engine) Matter.Composite.clear(engine.world, false, true);
            } catch (_) {}
            engine = null;

            // Move the six cards back to the Services grid in original order
            if (__grid && __originalCards && __originalCards.length) {
              __originalCards.forEach(function (el) {
                // remove float-only classes and inline styles
                el.classList.remove(
                  "flying-card",
                  "no-drag",
                  "launching",
                  "swap-on",
                  "playing"
                );
                el.style.transform = "";
                el.style.width = "";
                el.style.height = "";
                el.style.position = "";
                el.style.left = "";
                el.style.top = "";
                el.style.pointerEvents = "";
                el.style.background = "";
                el.style.color = "";
                el.style.willChange = "";
                el.style.userSelect = "";
                el.style.webkitUserSelect = "";
                el.style.webkitUserDrag = "";
                el.style.webkitTapHighlightColor = "";

                // restore original content visibility
                el.querySelectorAll("h3,p").forEach(function (n) {
                  n.style.display = "";
                  n.style.opacity = "";
                  n.style.visibility = "";
                  n.style.height = "";
                  n.style.margin = "";
                  n.style.pointerEvents = "";
                });
                var swap = el.querySelector(".title-swap");
                if (swap && swap.parentNode) swap.parentNode.removeChild(swap);

                __grid.appendChild(el);
              });
            }

            bodies = [];
          }

          // Expose to Party toggle
          window.__startFloatMode = start;
          window.__stopFloatMode = stop;
          window.__debugFloat = {
            on: false,
            set: function (on) {
              this.on = !!on;
              console.log("[float] debug", this.on ? "on" : "off");
            },
          };
        })();

        /* Reveal (replayable) */
        var els = [].slice.call(document.querySelectorAll("[data-animate]"));
        if ("IntersectionObserver" in window) {
          try {
            var io = new IntersectionObserver(
              function (entries) {
                for (var i = 0; i < entries.length; i++) {
                  var e = entries[i];
                  if (e.isIntersecting) e.target.classList.add("reveal");
                  else e.target.classList.remove("reveal");
                }
              },
              { rootMargin: "0px 0px -10% 0px", threshold: 0.1 }
            );
            els.forEach(function (el) {
              io.observe(el);
            });
          } catch (_) {
            els.forEach(function (el) {
              el.classList.add("reveal");
            });
          }
        } else {
          els.forEach(function (el) {
            el.classList.add("reveal");
          });
        }

        /* Drift (global) */
        var driftNodes = [].slice.call(
          document.querySelectorAll("[data-parallax],[data-drift]")
        );
        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }
        function driftTick() {
          var vh = window.innerHeight || 1;
          var sc = d.scrollTop || b.scrollTop;
          var rawScale = getComputedStyle(d)
            .getPropertyValue("--drift-scale")
            .trim();
          var scale = parseFloat(rawScale);
          if (isNaN(scale)) scale = 1;

          for (var i = 0; i < driftNodes.length; i++) {
            var el = driftNodes[i];
            var multY = parseFloat(el.getAttribute("data-drift"));
            if (!(multY || multY === 0))
              multY = el.hasAttribute("data-parallax") ? 1.2 : 0.7;
            var multX = parseFloat(el.getAttribute("data-drift-x"));
            if (!(multX || multX === 0)) multX = 0.55 * multY;

            var r = el.getBoundingClientRect();
            var center = r.top + r.height / 2;
            var norm = (center - vh / 2) / vh;

            // Stronger, more obvious drift (tunable via --drift-scale and Lab)
            var y = clamp(-60 * norm * multY * scale, -90, 90);
            var x = Math.sin(sc * 0.006 + i * 0.9) * (22 * multX * scale);

            el.style.setProperty("--dy", y + "px");
            el.style.setProperty("--dx", x + "px");
          }
          requestAnimationFrame(driftTick);
        }
        requestAnimationFrame(driftTick);

        /* Scroll progress */
        var bar = document.getElementById("scroll-progress");
        function progress() {
          var sc = d.scrollTop || b.scrollTop,
            max = d.scrollHeight - d.clientHeight || 1;
          if (bar) bar.style.width = (sc / max) * 100 + "%";
        }
        progress();
        document.addEventListener("scroll", progress, { passive: true });

        /* Mobile nav toggle */
        (function () {
          var nav = document.getElementById("nav");
          var btn = document.getElementById("nav-toggle");
          if (!nav || !btn) return;
          btn.addEventListener("click", function () {
            nav.classList.toggle("open");
          });
        })();

        /* Detect touch / coarse pointer for mobile behavior */
        var IS_COARSE =
          window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
        // Soften drift and thicken morph on mobile/tablet
        d.style.setProperty("--drift-scale", IS_COARSE ? 0.75 : 1.0);
        d.style.setProperty("--morph-stroke-min", IS_COARSE ? 16 : 22);
        d.style.setProperty("--morph-stroke-max", IS_COARSE ? 28 : 36);
        // ensure a default color exists so Lab can read/override
        if (
          !getComputedStyle(d).getPropertyValue("--morph-stroke-color").trim()
        ) {
          d.style.setProperty("--morph-stroke-color", "#2f6f64");
        }

        // end vibe core IIFE
      })();

      // ===== Dark/Light mode toggle =====
      (function () {
        const toggleBtn = document.querySelector(".theme-toggle");
        if (!toggleBtn) return;
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        const savedTheme = localStorage.getItem("theme");
        function setTheme(theme) {
          document.body.classList.remove("dark-mode", "light-mode");
          document.body.classList.add(theme + "-mode");
          document.documentElement.classList.remove("dark-mode", "light-mode");
          document.documentElement.classList.add(theme + "-mode");
          toggleBtn.textContent = theme === "dark" ? "🌞" : "🌙";
          localStorage.setItem("theme", theme);
        }
        // Initial theme
        if (savedTheme) {
          setTheme(savedTheme);
        } else {
          setTheme(prefersDark ? "dark" : "light");
        }
        // Toggle handler
        toggleBtn.addEventListener("click", () => {
          const current = document.body.classList.contains("dark-mode")
            ? "dark"
            : "light";
          setTheme(current === "dark" ? "light" : "dark");
        });
      })();
    </script>
  </body>
</html>

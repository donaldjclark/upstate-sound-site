<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      document.documentElement.classList.add("js");
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Upstate Sound &amp; Repair – Boutique audio service in Greenville, SC
    </title>

    <!-- Fonts + (optional) your external stylesheet -->
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Space+Grotesk:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css?v=4" />

    <style>
      /* ---------- Page frame / background gutters ---------- */
      html {
        background: url("assets/background.png") center / cover fixed no-repeat;
      }
      body {
        margin: 0;
        color: #e6e6e6;
        font-family: "Space Grotesk", system-ui, sans-serif;
        background: transparent;
      }

      :root {
        /* Seafoam glow palette (matches background shapes) */
        --glow-main: 47, 111, 100; /* #2F6F64 */
        --glow-halo: 31, 85, 77; /* a darker teal for the halo */

        /* runtime‑tunable vars */
        --drift-scale: 1;
        --morph-stroke-color: #7dd3fc; /* default cyan */
        --morph-stroke-min: 18;
        --morph-stroke-max: 28;
        --wave-speed: 0.001; /* 50% faster than 0.0006 */
        --wave-cycles: 4; /* number of undulations across the viewport */
        --morph-opacity: 0.24; /* try 0.18 ~ 0.35 */
      }

      /* Content column creates a local stacking context:
         ::before (0) = the dark column bg
         .morph-wrap (1) = the wave
         .section (2) = your content/cards
      */
      .content-frame {
        position: relative;
        max-width: 1100px;
        margin: 0 auto;
        background: transparent; /* bg moved to ::before so morph can sit above it */
        min-height: 100dvh;
        z-index: 2; /* creates local stacking context */
        overflow: visible;
      }
      .content-frame::before {
        content: "";
        position: fixed; /* fixed so column bg doesn’t scroll */
        left: 50vw;
        top: 0;
        transform: translateX(-50%);
        width: min(1100px, 92vw);
        height: 100vh;
        background: rgba(
          10,
          10,
          10,
          0.92
        ); /* slightly translucent so gutters peek */
        z-index: 0;
      }

      /* ===== MORPH: fixed, full-bleed; inside .content-frame stacking context (above sections so it’s never hidden) ===== */
      .morph-wrap {
        position: fixed;
        left: 0 !important;
        right: 0 !important;
        top: 50vh;
        transform: translateY(-50%);
        width: 100vw !important;
        height: 70vh;
        display: block;
        z-index: 6000; /* above sections so it’s never hidden */
        pointer-events: none;
        opacity: var(--morph-opacity, 0.24); /* now controlled via :root */
        mix-blend-mode: screen; /* additive light so it doesn’t block text */
      }
      .morph-wrap svg {
        width: 100%;
        height: 100%;
        overflow: visible;
        display: block;
      }

      html.party .morph-wrap {
        top: 50vh;
      }

      /* Make the morph path obey the CSS var color */
      .morph-wrap svg path[data-blend] {
        stroke: var(--morph-stroke-color, #2f6f64) !important;
      }

      /* Sections / cards: sections have a lower z-index than the morph now */
      .section {
        position: relative;
        z-index: 20;
        padding: 64px 24px;
      }
      .section.alt {
        background: #111;
      }

      h1,
      h2,
      h3 {
        margin: 0 0 16px;
        font-family: "Montserrat", system-ui, sans-serif;
        color: #f4f4f5;
      }
      p {
        color: #c9c9ce;
        line-height: 1.6;
      }

      /* ---------- Header / Hero ---------- */
      #hero {
        position: relative;
        padding: 80px 24px 48px;
        text-align: center;
      }
      .hero-overlay {
        position: absolute;
        inset: 0;
        background: linear-gradient(
          180deg,
          rgba(250, 249, 246, 0) 0%,
          rgba(10, 10, 10, 0.08) 45%,
          rgba(10, 10, 10, 0.6) 100%
        );
        pointer-events: none;
        z-index: 0;
      }
      .logo {
        display: block;
        margin: 0 auto 24px;
        width: 220px;
        height: auto;
      }

      /* Size inline SVG placed inside .logo container */
      .logo svg {
        width: 220px;
        height: auto;
        display: block;
        margin: 0 auto 24px;
      }

      /* Tagline “tape wobble” + glow for contrast */
      .tape {
        display: inline-block;
        animation: tapeWobble 1.2s ease-in-out infinite;
        transform-origin: 50% 50%;
      }
      @keyframes tapeWobble {
        0% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
        25% {
          transform: translateY(-1px) rotate(0.22deg) skewX(-0.1deg);
        }
        50% {
          transform: translateY(0.6px) rotate(-0.14deg) skewX(0.06deg);
        }
        75% {
          transform: translateY(-0.8px) rotate(0.18deg) skewX(-0.06deg);
        }
        100% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .tape {
          animation: none;
        }
      }

      /* Tagline glow (seafoam-only) */
      #hero h1.tape {
        text-shadow: 0 0 3px rgba(var(--glow-main), 0.55),
          0 0 8px rgba(var(--glow-halo), 0.4),
          0 0 16px rgba(var(--glow-main), 0.22);
      }

      .logo {
        isolation: isolate;
      } /* prevent blending weirdness with backdrop */
      .logo svg,
      .logo svg * {
        /* Subtle seafoam glow to match tagline */
        filter: drop-shadow(0 0 2px rgba(var(--glow-main), 0.42))
          drop-shadow(0 0 5px rgba(var(--glow-halo), 0.32))
          drop-shadow(0 0 10px rgba(var(--glow-main), 0.18));
        transition: filter 120ms ease-out;
      }

      /* Nav (desktop/tablet default) */
      #nav {
        display: flex;
        justify-content: flex-end;
        gap: 24px;
        margin-bottom: 12px;
        align-items: center;
      }
      #nav a {
        color: #b9b9ff;
        text-decoration: none;
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      #nav-toggle {
        display: none;
      }

      /* Glitch links */
      a.glitch {
        position: relative;
        display: inline-block;
        text-decoration: none;
      }
      a.glitch::before,
      a.glitch::after {
        content: attr(data-text);
        position: absolute;
        inset: 0;
        opacity: 0;
        mix-blend-mode: screen;
      }
      a.glitch::before {
        color: #22d3ee;
      }
      a.glitch::after {
        color: #a78bfa;
      }
      @keyframes glitchX {
        0% {
          transform: translate(0, 0);
        }
        20% {
          transform: translate(1px, -1px);
        }
        40% {
          transform: translate(-1px, 1px);
        }
        60% {
          transform: translate(2px, 0);
        }
        80% {
          transform: translate(-2px, 1px);
        }
        100% {
          transform: translate(0, 0);
        }
      }
      a.glitch:hover::before,
      a.glitch:hover::after {
        opacity: 0.7;
        animation: glitchX 0.18s steps(2, end) infinite;
      }

      /* Services grid (base = desktop 3 cols) */
      .services-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 28px;
      }
      .service-card {
        background: #f4f2eb;
        color: #142;
        border-radius: 12px;
        padding: 22px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }
      @media (hover: hover) and (pointer: fine) {
        .service-card:hover {
          outline: 1px solid rgba(255, 255, 255, 0.08);
          transform: translateY(-1px);
          transition: transform 120ms ease-out, outline-color 120ms ease-out;
        }
      }
      .service-card h3 {
        color: #0b2340;
      }
      .service-card p {
        color: #213;
      }

      /* Sticky Services title */
      .services-sticky {
        position: sticky;
        top: 0;
        z-index: 20;
        background: linear-gradient(#0a0a0acc, #0a0a0acc);
        backdrop-filter: blur(4px);
        padding: 10px 24px;
        margin: -10px -24px 16px;
      }

      /* Past work */
      .work-section ul {
        padding-left: 20px;
      }
      .work-section li {
        margin: 12px 0;
      }

      /* Paper panel for About */
      .paper {
        background: #f4f2eb;
        color: #111;
        border-radius: 12px;
        padding: 24px clamp(16px, 2vw, 28px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.18);
      }
      .paper h2 {
        color: #111;
      }
      .paper p {
        color: #222;
      }

      /* Footer */
      .footer {
        padding: 32px 24px;
        text-align: center;
        color: #aaa;
      }

      /* Reveal + drift (CSS vars written by JS) */
      [data-animate] {
        opacity: 1;
        --revealY: 0px;
        --dy: 0px;
        --dx: 0px;
        transform: translate3d(var(--dx), calc(var(--revealY)+var(--dy)), 0);
      }
      .js [data-animate] {
        opacity: 0;
        --revealY: 24px;
        transition: opacity 0.7s cubic-bezier(0.22, 1, 0.36, 1),
          transform 0.7s cubic-bezier(0.22, 1, 0.36, 1);
        will-change: transform, opacity;
      }
      .reveal {
        opacity: 1 !important;
        --revealY: 0px;
      }

      /* Progress bar */
      #scroll-progress {
        position: fixed;
        inset: 0 auto auto 0;
        height: 3px;
        width: 0%;
        background: linear-gradient(90deg, #22d3ee, #a78bfa);
        z-index: 9999;
      }

      /* ====== PARTY MODE VISUALS (revived) ====== */
      @keyframes hueRoll {
        from {
          filter: hue-rotate(0);
        }
        to {
          filter: hue-rotate(360deg);
        }
      }
      @keyframes slowTilt {
        0% {
          transform: rotate(0.02deg);
        }
        50% {
          transform: rotate(-0.02deg);
        }
        100% {
          transform: rotate(0.02deg);
        }
      }
      @keyframes glowPulse {
        0% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
        50% {
          text-shadow: 0 0 12px rgba(var(--glow-halo), 0.75),
            0 0 26px rgba(var(--glow-main), 0.48);
        }
        100% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
      }
      /* Richer/faster hue cycle for cards in party (Konami) mode */
      @keyframes hueSpinRich {
        from {
          filter: hue-rotate(0deg) saturate(1) contrast(1.05) brightness(1);
        }
        50% {
          filter: hue-rotate(180deg) saturate(1.7) contrast(1.12)
            brightness(1.06);
        }
        to {
          filter: hue-rotate(360deg) saturate(1) contrast(1.05) brightness(1);
        }
      }
      /* Apply to normal grid cards and floating cards; also colorize during Float Mode */
      /* Float/Party color model: all cards go black; only the playing one glows */
      html.party .flying-card,
      html.float-on .flying-card {
        background: var(--base, #0a0a0a);
        color: #fff;
        filter: none;
        animation: none;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.28);
      }
      html.party .flying-card .title-swap,
      html.float-on .flying-card .title-swap {
        color: #fff;
      }
      html.party .flying-card:not(.playing),
      html.float-on .flying-card:not(.playing) {
        filter: none; /* keep their individual dark base colors visible */
      }
      html.party .flying-card.playing,
      html.float-on .flying-card.playing {
        outline: 2px solid var(--accent, #7dd3fc);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }
      html.party .content-frame::before{
        background: rgba(10,10,10,0.85); /* a hair lighter so the RGB bands show through */
  }
      /* Canvas overlay that draws the live waveform on the active card */
      .flying-card .wave,
      .service-card .wave {
        position: absolute;
        inset: 0;
        z-index: 5;
        pointer-events: none;
        opacity: 0.85;
        mix-blend-mode: screen;
      }
      /* Extra emphasis for the currently playing card */
      .flying-card.playing,
      .service-card.playing {
        box-shadow: inset 0 0 0 2px rgba(var(--glow-main), 0.55),
          0 10px 24px rgba(0, 0, 0, 0.28), 0 0 16px rgba(var(--glow-main), 0.32),
          0 0 28px rgba(var(--glow-halo), 0.26);
      }
      html.party .content-frame {
        animation: hueRoll 14s linear infinite;
      }
      html.party .section {
        animation: slowTilt 7s ease-in-out infinite;
      }
      html.party a,
      html.party h1,
      html.party h2,
      html.party h3,
      html.party .reveal {
        animation: glowPulse 1.8s ease-in-out infinite;
      }
      /* Keep the wobble AND add the glow for the tagline */
      html.party #tagline {
        animation: tapeWobble 1.2s ease-in-out infinite,
          glowPulse 1.8s ease-in-out infinite;
      }
      /* Film grain canvas shown only in party-mode */
      #grain {
        position: fixed;
        inset: 0;
        z-index: 8000;
        pointer-events: none;
        opacity: 0.28;
        display: none;
      }
      html.party #grain { display:block; opacity:.42; } /* stronger in party */
      /* Keep morph centered & viewport-fixed in party mode */
      html.party .morph-wrap {
        position: fixed !important;
        top: 50vh !important;
        left: 0 !important;
        right: 0 !important;
        transform: translateY(-50%) !important;
        z-index: 7000 !important; /* below grain (8000) and lab (9000) */
      }
      
      /* Layer that holds drifting cards (fixed, overlays viewport) */
      #float-layer {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 8500;
        /* was: pointer-events: auto; */
        pointer-events: none;           /* let scroll pass through the overlay */
        /* was: touch-action: pan-y;   ← remove this line */
        overflow: visible;
      }

      /* Float Mode (uses the actual six service cards) */
      .flying-card {
        position: absolute; /* inside #float-layer */
        z-index: 1;
        will-change: transform, opacity;
        backface-visibility: hidden;
        pointer-events: auto; /* clickable for audio */
        transform: translate3d(0, 0, 0);
        transform-origin: center center; /* ensures rotations spin around center */
        left: 0;
        top: 0; /* transform origin is the viewport’s top-left */
        user-select: none; /* avoid text selection while drifting */
        /* ensure the first paint uses the on-card transform we set from JS */
      }
      .flying-card .title-swap {
        position: absolute;
        left: 12px;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 700;
        color: #0b2340;
        text-align: center;
        line-height: 1.2;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none; /* prevent accidental selection while floating */
      }
      .flying-card.swap-on .title-swap {
        opacity: 1;
      }
      .flying-card.swap-on h3,
      .flying-card.swap-on p {
        opacity: 0 !important;
        visibility: hidden !important;
        display: none !important;
        height: 0 !important;
        margin: 0 !important;
        pointer-events: none !important;
      }

      /* --- Hover/press lift for floating cards + accessible focus --- */
      html.float-on .flying-card:hover,
      html.party .flying-card:hover {
        z-index: 8700;
        box-shadow: 0 14px 32px rgba(0,0,0,.38), 0 0 18px var(--accent, #7dd3fc);
      }

      html.float-on .flying-card:active,
      html.party .flying-card:active {
        transform: translate3d(var(--fx,0px), var(--fy,0px), 0) rotate(var(--fa,0rad)) scale(.98);
      }

      a:focus-visible, button:focus-visible, .service-card:focus-visible, .flying-card:focus-visible {
        outline: 2px dashed #b9b9ff;
        outline-offset: 3px;
        border-radius: 10px;
      }

      /* === Float launch visuals (size shrink + soft pulse) === */
      /* Quick-change: service cards fly off-stage to the left when Party begins */
      @keyframes flyOutLeft{
        0%   { transform: translate(0,0) rotate(0deg) scale(1); opacity:1; filter:blur(0); }
        60%  { transform: translate(-26vw,-6vh) rotate(-4deg) scale(.94); opacity:.6; filter:blur(1px); }
        100% { transform: translate(-42vw,-8vh) rotate(-8deg) scale(.88); opacity:0; filter:blur(2px); }
      }
      .services-section .service-card.vanish{
        animation: flyOutLeft 380ms cubic-bezier(.22,1,.36,1) forwards;
        will-change: transform, opacity, filter;
      }
      .flying-card {
        transition: width 320ms cubic-bezier(0.22, 1, 0.36, 1),
          height 320ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 260ms ease;
      }
      .flying-card.launching {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35),
          0 0 0 0 rgba(125, 211, 252, 0);
      }
      .flying-card.launching.playing {
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }

      /* =========================
         RESPONSIVE LAYOUT LAYER
         ========================= */

      /* Tablet (821px–1099px): 2 columns */
      @media (max-width: 1099px) {
        .services-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      /* =========================
         MOBILE FIX PACK (≤ 820px)
         ========================= */
      @media (max-width: 820px) {
        :root {
          --morph-stroke-min: 16;
          --morph-stroke-max: 28;
        }
        :root {
          --drift-scale: 0.75;
        }
        /* Column “paper”: fill more of the screen but keep gutter image visible */
        .content-frame::before {
          width: min(100vw, 96vw);
          background: rgba(10, 10, 10, 0.95);
        }

        /* Sections: tighter padding for readability */
        .section {
          padding: 40px 18px;
        }

        /* Hero: logo + tagline scale and glow for contrast */
        .logo {
          width: clamp(140px, 38vw, 200px);
        }
        #hero h1.tape {
          font-size: clamp(22px, 7vw, 36px);
          line-height: 1.08;
          text-shadow: 0 0 4px rgba(var(--glow-main), 0.6),
            0 0 10px rgba(var(--glow-halo), 0.44),
            0 0 18px rgba(var(--glow-main), 0.3);
        }

        /* Nav: real mobile menu (button toggles .open) */
        #nav {
          align-items: center;
          justify-content: space-between;
          gap: 0;
        }
        #nav-toggle {
          display: inline-block;
          font-size: 22px;
          background: transparent;
          color: #b9b9ff;
          border: 0;
        }
        /* collapse links by default */
        #nav .glitch {
          display: none;
          padding: 12px 0;
        }
        #nav .glitch + .glitch {
          border-top: 1px solid rgba(255, 255, 255, 0.06);
        }
        /* show when nav is opened */
        #nav.open .glitch {
          display: block;
        }

        /* Services: single column, bigger touch targets */
        .services-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .service-card {
          padding: 18px 16px;
          border-radius: 10px;
          box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        }
        .service-card h3 {
          font-size: clamp(18px, 5.2vw, 22px);
        }
        .service-card p {
          font-size: clamp(14px, 4.2vw, 16px);
          line-height: 1.55;
        }

        /* Sticky “Services” title: less jumpy */
        .services-sticky {
          top: 0;
          padding: 10px 16px;
          margin: -10px -16px 12px;
          background: linear-gradient(#0a0a0acc, #0a0a0acc);
          backdrop-filter: blur(4px);
        }

        /* Past Work spacing */
        .work-section li {
          margin: 10px 0;
        }

        /* Morph: a bit smaller/taller for clarity on phones */
        .morph-wrap {
          width: 100vw;
          height: 55vh;
          opacity: var(--morph-opacity, 0.24);
          mix-blend-mode: screen;
        }
        .morph-wrap svg {
          width: 100%;
          height: 100%;
        }

        /* Footer: breathing room */
        .footer {
          padding: 28px 16px;
          font-size: 14px;
        }

        /* Disable keyboard-only hints: Konami is long‑press / double‑tap on mobile */
        .services-sticky {
          position: sticky;
        } /* keep */
        #grain {
          opacity: 0.22;
        } /* slightly softer on phone */

        /* Thumb-sized floating song cards (mobile only) */
        html.float-on .flying-card,
        html.party .flying-card {
          width: clamp(88px, 22vw, 120px) !important;
          height: clamp(88px, 22vw, 120px) !important;
          padding: 10px !important;
          border-radius: 12px !important;
        }

        html.float-on .flying-card .title-swap,
        html.party .flying-card .title-swap {
          font-size: clamp(10px, 3.4vw, 13px) !important;
          line-height: 1.15 !important;
          left: 6px;
          right: 6px;
        }

        html.float-on .flying-card .wave,
        html.party .flying-card .wave {
          opacity: 0.9;
        }
      }

      /* Ultra-small devices (≤ 380px) */
      @media (max-width: 380px) {
        .section {
          padding: 32px 14px;
        }
        .services-sticky {
          margin: -10px -14px 10px;
          padding: 10px 14px;
        }
      }
    </style>
  </head>
  <body>
    <div id="scroll-progress" aria-hidden="true"></div>
    <canvas id="grain" aria-hidden="true"></canvas>
    <audio id="player" preload="none" style="display: none"></audio>
    <div id="float-layer" aria-hidden="true"></div>
    <!-- Content column (bg via ::before) -->
    <div class="content-frame">
      <!-- Morph sits between column background (::before) and content cards -->
      <div class="morph-wrap" aria-hidden="true">
        <div id="morph-svg"></div>
      </div>
      <header id="hero" class="section" data-animate>
        <nav id="nav" data-animate>
          <button id="nav-toggle" aria-label="Toggle navigation">☰</button>
          <a href="#about" class="glitch" data-text="About" data-animate
            >About</a
          >
          <a href="#services" class="glitch" data-text="Services" data-animate
            >Services</a
          >
          <a href="#work" class="glitch" data-text="Past Work" data-animate
            >Past Work</a
          >
          <a href="#contact" class="glitch" data-text="Contact" data-animate
            >Contact</a
          >
        </nav>

        <div class="hero-overlay"></div>
        <div
          class="logo"
          id="logo-inline"
          aria-label="Upstate Sound &amp; Repair logo"
          data-animate
        ></div>
        <h1 id="tagline" class="tape" data-parallax data-drift="1.2">
          Where Sound Meets Vision.
        </h1>
      </header>

      <main>
        <!-- About -->
        <section id="about" class="section about-section paper" data-animate>
          <h2 data-animate>About</h2>
          <p data-animate>
            Hey, I’m Donald—a lifelong chaser of tone and tinkerer of broken
            gear. I’m an audio engineer, live-sound tech, repair whisperer, and,
            on rare occasions, a musician who actually finishes a song. If
            you’re here, you probably care about your gear as much as your
            music—so do I.
          </p>
          <p data-animate>
            Upstate Sound &amp; Repair is my way of keeping our little corner of
            the world humming, one recalcitrant circuit at a time. I consult for
            venues, help artists chase good sound, and I show up when your
            vintage Moog throws a tantrum or your podcast needs a little love.
            If you want work done right (but not uptight), I’m the guy who shows
            up with a soldering iron, way too many opinions, and a sense of
            humor.
          </p>
        </section>

        <!-- Services -->
        <section
          id="services"
          class="section services-section alt"
          data-animate
        >
          <h2 class="services-sticky" data-animate>Services</h2>
          <div class="services-grid">
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Studio &amp; Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Your studio is only as good as its weakest link. I diagnose and
                repair mixers, preamps, tape machines, and all those vintage
                boxes you can’t live without. Think of me as your gear’s
                therapist — I listen carefully and I don’t judge.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Synth &amp; Audio Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Analog synths are living, breathing beasts — and they get
                cranky. I service and restore vintage synthesizers, drum
                machines, samplers and outboard gear. Whether it’s a cracked
                membrane or a blown capacitor, I’ll get the soul back in your
                circuits.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Music Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                I partner with bands and solo artists to produce, record and
                shape their music. From pre-production and arrangement to mixing
                and mastering, I help you capture what you hear in your head and
                translate it to tape. No cookie-cutter templates — just honest
                collaboration and sonic exploration.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Podcast Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Have a story to tell? I provide recording, editing and mixing
                for podcasts and audio books. I’ll help you sound like you know
                what you’re doing — crisp vocals, balanced levels, and maybe the
                occasional tasteful synth stab.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Live Sound Engineering
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                From tiny clubs to weird warehouse gatherings, I mix live shows
                that feel like they’re meant for you. Clean, loud and
                feedback-free. Yes, I’ll carry cases and tape cables because I’m
                not above grunt work.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Consulting &amp; Education
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                One-on-one consulting for studios, bands, and venues.
                Signal-flow bootcamps, mix reviews, live rig sanity checks, and
                hands-on solder sessions. Learn the why, not just the settings.
              </p>
            </div>
          </div>
        </section>

        <!-- Past Work -->
        <section id="work" class="section work-section" data-animate>
          <h2 data-animate>Past Work</h2>
          <ul class="work-list">
            <li data-animate data-drift="0.8">
              <strong>Live &amp; Session Engineer – Artis-Naples:</strong>
              engineered recordings for the Naples Philharmonic Orchestra and
              various chamber ensembles at Artis-Naples (home of the Naples
              Philharmonic).
            </li>
            <li data-animate data-drift="0.8">
              <strong>Mix Consultant – Swansons Studios:</strong> partnered with
              Britt to fine-tune session mixes for local bands, offering fresh
              ears, technical fixes and workflow hacks.
            </li>
            <li data-animate data-drift="0.8">
              <strong
                >Producer &amp; Mix Engineer – 10-Song LP (in progress):</strong
              >
              producing, recording, mixing and mastering a full-length album —
              custom synth patches, recorded instruments, a few talk-radio
              samples — 100% handcrafted, all original.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Podcast Producer – Trailside Carolina:</strong> recorded,
              produced, mixed and mastered the Trailside Carolina podcast —
              crystal-clear audio and immersive storytelling for outdoor
              enthusiasts.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Gear Repair Repertoire:</strong> Yamaha DX7/DX7IIFD, CS01,
              CS50/60, SK-20, Microkorg, Lexicon 300, Korg SK1, Kawai K1, Roland
              JP-3000 &amp; RE-201, Ibanez TS-9, Mu-Tron III, Fender Twin
              (reissue), Pro Reverb (1967), Musicman HD-150, ART PRO VLA II, A
              Designs MP-2A… and many more.
            </li>
          </ul>
        </section>

        <!-- Contact -->
        <section id="contact" class="section contact-section" data-animate>
          <h2 data-animate>Contact</h2>
          <p data-animate>
            Ready to get that crackling amp sorted, record a new podcast or just
            chat about synths? Drop me a line — I’m based in Greenville, South
            Carolina and I love meeting fellow audio nerds.
          </p>
          <p data-animate>
            Email me at
            <a
              class="glitch"
              href="mailto:info@upstatesound.co"
              data-text="info@upstatesound.co"
              >info@upstatesound.co</a
            >.
          </p>
        </section>
      </main>

      <footer class="footer">
        <p>
          © <span id="year"></span> Upstate Sound &amp; Repair. Serving
          Greenville and the Upstate. Made with solder and soul.
        </p>
      </footer>
    </div>

    <!-- Optional: your existing JS -->
    <script src="script.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

    <!-- Vibe core -->
    <script>
      (function () {
        var d = document.documentElement,
          b = document.body;

        /* Inline the logo.svg so CSS glow can target its paths */
        (function () {
          // === Waveform rendering on the active card ==========================
          var __waveCard = null,
            __waveCtx = null,
            __waveCvs = null,
            __waveRAF = 0;

          function attachWaveToCard(card) {
            if (!card) return;
            var cvs = card.querySelector(".wave");
            if (!cvs) {
              cvs = document.createElement("canvas");
              cvs.className = "wave";
              card.appendChild(cvs);
            }
            __waveCvs = cvs;
            __waveCtx = cvs.getContext("2d");
            // fit to card box
            function size() {
              var r = card.getBoundingClientRect();
              cvs.width = Math.max(2, Math.floor(r.width));
              cvs.height = Math.max(2, Math.floor(r.height));
            }
            size();
            // re-fit on next frame (after CSS/layout settles)
            requestAnimationFrame(size);
            __waveCard = card;
          }

          function stopWave() {
            if (__waveRAF) cancelAnimationFrame(__waveRAF);
            __waveRAF = 0;
            if (__waveCard) {
              var c = __waveCard.querySelector(".wave");
              if (c) {
                c.getContext("2d").clearRect(0, 0, c.width, c.height);
              }
              __waveCard.classList.remove("playing");
            }
            __waveCard = null;
          }

          function startWaveOn(card) {
            if (!window.__waveAnalyser || !card) return;
            attachWaveToCard(card);
            card.classList.add("playing");

            var analyser = window.__waveAnalyser;
            var buf = new Uint8Array(analyser.fftSize);

            function draw() {
              if (!__waveCtx || !__waveCvs) return;
              analyser.getByteTimeDomainData(buf);

              var w = __waveCvs.width,
                h = __waveCvs.height;
              var ctx = __waveCtx;
              ctx.clearRect(0, 0, w, h);

              // soft glow trail
              ctx.lineWidth = 3;
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.shadowBlur = 14;
              ctx.shadowColor = "rgba(255,255,255,0.9)";
              ctx.beginPath();

              for (var i = 0; i < buf.length; i++) {
                var x = (i / (buf.length - 1)) * w;
                var y = (buf[i] / 255) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.stroke();
              __waveRAF = requestAnimationFrame(draw);
            }
            stopWave(); // stop previous
            __waveRAF = requestAnimationFrame(draw);
          }
          // Expose waveform helpers globally
          window.__startWaveOn = startWaveOn;
          window.__stopWave = stopWave;
          var holder = document.getElementById("logo-inline");
          if (!holder) return;
          fetch("assets/logo.svg")
            .then(function (r) {
              return r.text();
            })
            .then(function (svg) {
              holder.innerHTML = svg;
            })
            .catch(function (e) {
              console.warn("inline logo failed", e);
            });
        })();

        /* === Float Mode (Matter.js orbital drift) — unique physics, free rotation, per-card colors === */
        (function () {
          var player = document.getElementById("player");
          var layer = document.getElementById("float-layer");
          if (!layer) {
            layer = document.createElement("div");
            layer.id = "float-layer";
            document.body.appendChild(layer);
          }
          layer.style.display = "block";
layer.style.width = "100vw";
layer.style.height = "100vh";
layer.style.zIndex = "8500";   // keep this so float-layer sits above content
// no pointerEvents, no touchAction here


          // Titles ↔ tracks (1:1 with service cards on the page)
          var TITLES = [
            "Resting Place",
            "Deletions of Grandeur",
            "God of No Man",
            "Is There a Number to The Other Side?",
            "Sad News",
            "Spiritually Dead",
          ];
          var TRACKS = [
            "assets/resting-place.mp3",
            "assets/deletions-of-grandeur.mp3",
            "assets/god-of-no-man.mp3",
            "assets/is-there-a-number-to-the-other-side.mp3",
            "assets/sad-news.mp3",
            "assets/spiritually-dead.mp3",
          ];
          // Darker party palette per card
          var BASES = [
            "#0b1f2a",
            "#10231f",
            "#1e1722",
            "#231b10",
            "#122018",
            "#1b2130",
          ];

          // High-contrast accents (used for the playing card + morph stroke)
          var ACCENTS = ["#7dd3fc","#a78bfa","#fb7185","#f59e0b","#34d399","#60a5fa"];

          // Matter primitives
          var Engine = window.Matter && Matter.Engine;
          var Bodies = window.Matter && Matter.Bodies;
          var Composite = window.Matter && Matter.Composite;
          var Runner = window.Matter && Matter.Runner;
          var Events = window.Matter && Matter.Events;
          var Mouse = window.Matter && Matter.Mouse;
          var MouseConstraint = window.Matter && Matter.MouseConstraint;
          var engine = null,
            runner = null;
          var __idleT = 0; // seconds since float mode started (for independent idle drift)
          var bodies = []; // {el, body, w, h}
          var ticking = 0;
          var ACTIVE = false;

          // --- Scroll-triggered turbulence (makes things jumble like pebbles) ---
          var burstUntil = 0;
          function jostle(durationMs, power) {
            var now = performance.now();
            burstUntil = Math.max(burstUntil, now + (durationMs || 220));
            if (!power) power = 1;

            function turbulenceFrame() {
              var t = performance.now();
              if (t >= burstUntil) return;
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i].body;
                // small random forces in both axes + a touch of spin
                var fx = (Math.random() - 0.5) * 0.0025 * power;
                var fy = (Math.random() - 0.5) * 0.0025 * power;
                Matter.Body.applyForce(b, b.position, { x: fx, y: fy });
                b.angularVelocity += (Math.random() - 0.5) * 0.06 * power;
              }
              requestAnimationFrame(turbulenceFrame);
            }
            requestAnimationFrame(turbulenceFrame);
          }

          function ensureAnalyser() {
            try {
              if (!window.__waveAnalyser && player) {
                var AC = window.AudioContext || window.webkitAudioContext;
                var ctx = new AC();
                var srcNode = ctx.createMediaElementSource(player);
                var analyser = ctx.createAnalyser();
                analyser.fftSize = 1024;
                srcNode.connect(analyser);
                analyser.connect(ctx.destination);
                window.__waveAnalyser = analyser;
              }
            } catch (_) {}
          }

          function playTrackSrc(src, card) {
            if (!player) return;
            var same = player.src && player.src.endsWith(src);
            if (same && !player.paused) {
              player.pause();
              if (window.__stopWave) window.__stopWave();
              bodies.forEach(function (b) {
                b.el.classList.remove("playing");
              });
              return;
            }
            if (!same) player.src = src;

            // pick a stable accent color by the card's index (fallback cyan)
            var idx = 0;
            if (card) {
              var label = (card.__bodyRef && card.__bodyRef.label) || "";
              var m = /card-(\d+)/.exec(label);
              if (m) idx = (+m[1]) % ACCENTS.length;
            }
            var acc = ACCENTS[idx] || "#7dd3fc";
            // morph line follows the track’s accent
            document.documentElement.style.setProperty("--morph-stroke-color", acc);
            if (card) card.style.setProperty("--accent", acc);

            var p = player.play();
            ensureAnalyser();
            bodies.forEach(function (b) {
              b.el.classList.remove("playing");
            });
            if (card && window.__startWaveOn) window.__startWaveOn(card);
            if (p && typeof p.catch === "function") p.catch(function () {});
            card && card.classList.add("playing");
          }

          function buildWorld() {
            engine = Engine.create({ enableSleeping: false });
            engine.gravity.y = 0; // we drive motion with gentle impulses + scroll

            // Full-viewport bounds (thick static walls)
            function makeWalls() {
              var W = window.innerWidth,
                H = window.innerHeight,
                T = 120;
              var walls = [
                Bodies.rectangle(W / 2, -T / 2, W + T * 2, T, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(W / 2, H + T / 2, W + T * 2, T, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(-T / 2, H / 2, T, H + T * 2, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(W + T / 2, H / 2, T, H + T * 2, {
                  isStatic: true,
                  restitution: 0.95,
                }),
              ];
              walls.forEach(function (w) {
                w.label = "wall";
              });
              walls.forEach(function (w) {
                Composite.add(engine.world, w);
              });
            }
            makeWalls();

            // Build bodies out of the six service cards
            var cards = [].slice.call(
              document.querySelectorAll(
                "#services .services-grid .service-card"
              )
            );
            if (!cards.length) return;

            var snaps = cards.map(function (card) {
              var r = card.getBoundingClientRect();
              // document-space coordinates (robust against scroll state)
              var docX = (r.left + window.scrollX) + r.width  / 2;
              var docY = (r.top  + window.scrollY) + r.height / 2;
              return {
                card: card,
                docX: docX,
                docY: docY,
                w: r.width,
                h: r.height,
              };
            });

            layer.style.display = "block";
            layer.style.width = "100vw";
            layer.style.height = "100vh";

            var isCoarse =
              (window.matchMedia &&
                window.matchMedia("(pointer: coarse)").matches) ||
              "ontouchstart" in window;

            bodies = [];
            var cx = innerWidth / 2,
              cy = innerHeight / 2;
            snaps.forEach(function (snap, i) {
              var el = snap.card;

              // 5) Seed a randomized rotation angle variable if not already present
              var initA = Math.random() * Math.PI * 2;

              // Move into overlay and stylize
              layer.appendChild(el);
              el.classList.add("flying-card", "swap-on");
              el.style.position = "absolute";
              el.style.pointerEvents = "auto";
              el.style.background = BASES[i % BASES.length];
              el.style.color = "#fff";

              // Stage visual continuity: start at the service card's on-page position
              // and its original size, then shrink to the float size with a soft pulse.
              var origW = Math.round(snap.w);
              var origH = Math.round(snap.h);
              el.style.width = origW + "px";
              el.style.height = origH + "px";
              el.style.transformOrigin = "center center";

              // Compute start position in viewport coords (center of original card)
              var startX = 0,
                startY = 0; // temp placeholders; real values set below

              // Centered title only
              var swap = el.querySelector(".title-swap");
              if (!swap) {
                swap = document.createElement("div");
                swap.className = "title-swap";
                el.appendChild(swap);
              }
              swap.textContent = TITLES[i % TITLES.length];
              var h3 = el.querySelector("h3");
              if (h3) {
                var fs = getComputedStyle(h3).fontSize;
                var lh = getComputedStyle(h3).lineHeight;
                swap.style.fontSize = fs;
                if (lh && lh !== "normal") swap.style.lineHeight = lh;
              }
              el.querySelectorAll("h3,p").forEach(function (n) {
                n.style.display = "none";
              });

              // 4) Click-and-drag to fling (while preserving tap-to-play)
              (function (trackSrc, cardEl) {
                cardEl.__track = trackSrc;
                cardEl.addEventListener("click", function (ev) {
                  ev.stopPropagation();
                  if (
                    window.__draggingBodies &&
                    cardEl.__bodyRef &&
                    window.__draggingBodies.has(cardEl.__bodyRef)
                  ) {
                    return; // ignore clicks when the body is being dragged
                  }
                  playTrackSrc(cardEl.__track, cardEl);
                });
              })(TRACKS[i % TRACKS.length], el);
              el.style.touchAction = "none"; // better touch dragging

              // Project document coords into the current viewport so we never all spawn from left
              var viewX = snap.docX - window.scrollX;
              var viewY = snap.docY - window.scrollY;

              // If the Services section is off-screen, wrap into the viewport with a bit of jitter
              var jitter = 16;
              var startX = Math.max(40, Math.min(innerWidth  - 40, ((viewX % innerWidth)  + innerWidth) % innerWidth))  + (Math.random()*jitter - jitter/2);
              var startY = Math.max(40, Math.min(innerHeight - 40, ((viewY % innerHeight) + innerHeight) % innerHeight)) + (Math.random()*jitter - jitter/2);

              // Paint the card exactly over its old spot (transform-only),
              // then we animate the shrink. Keep initial random rotation.
              el.style.transform =
                "translate3d(" +
                (startX - origW / 2).toFixed(1) +
                "px," +
                (startY - origH / 2).toFixed(1) +
                "px,0) rotate(" +
                initA.toFixed(3) +
                "rad)";
              // Freeze the first paint so it doesn't flash at (0,0)
              el.offsetHeight; // force layout

              // Decide float size (mobile = thumb; desktop = 50%) and animate the shrink
              var W = snap.w,
                H = snap.h;
              if (isCoarse) {
                var TW = Math.max(
                  88,
                  Math.min(120, Math.round(innerWidth * 0.22))
                );
                W = H = TW;
              } else {
                W = Math.round(snap.w * 0.5);
                H = Math.round(snap.h * 0.5);
              }

              // Smoothly shrink from original size to float size
              el.classList.add("launching");
              requestAnimationFrame(function () {
                el.style.width = W + "px";
                el.style.height = H + "px";
                // remove the launch emphasis after the transition window
                setTimeout(function () {
                  el.classList.remove("launching");
                }, 400);
                setTimeout(function(){
                  // Sync physics size to the final DOM size after the shrink
                  try {
                    Matter.Body.setVertices(body, Matter.Vertices.fromPath('0 0 ' + W + ' 0 ' + W + ' ' + H + ' 0 ' + H));
                    Matter.Body.setInertia(body, (body.mass * Math.max(W, H) * Math.max(W, H)) / 12);
                  } catch(_){}
                }, 340);
              });

              // 3) Free rotation immediately (remove inertia: Infinity)
              var body = Bodies.rectangle(startX, startY, W, H, {
                restitution: 0.6,
                frictionAir: 0.004 + Math.random() * 0.003,
                friction: 0.001,
                density: 0.0008,
                // inertia: Infinity, // REMOVED
                chamfer: { radius: 12 },
                angle: initA,
              });
              body.__idle = {
                // leaf-on-water: slower frequencies + stronger micro-forces
                ax: 0.00035 + Math.random() * 0.00025, // x force amplitude
                ay: 0.00035 + Math.random() * 0.00025, // y force amplitude
                fx: 0.06 + Math.random() * 0.12,       // x frequency (very slow)
                fy: 0.06 + Math.random() * 0.12,       // y frequency (very slow)
                px: Math.random() * Math.PI * 2,       // x phase
                py: Math.random() * Math.PI * 2,       // y phase
                t0: Math.random() * 10.0               // per-card time offset so waves are de-synced
              };
              body.label = "card-" + i;
              Composite.add(engine.world, body);
              bodies.push({ el: el, body: body, w: W, h: H });
              // 4) After pushing to bodies, add .__bodyRef for drag detection
              el.__bodyRef = body;

              // Softer randomized start so each card begins independently
              var baseV = (isCoarse ? 1.2 : 0.9);
              Matter.Body.setVelocity(body, {
                x: (Math.random() - 0.5) * baseV,
                y: (Math.random() - 0.5) * baseV
              });
              body.angularVelocity = (Math.random() - 0.5) * 2.2;
            });
            // Bind Matter's mouse to the document so scrolling isn't captured by the overlay
var mouse = Mouse.create(document.body);
mouse.pixelRatio = window.devicePixelRatio || 1;

var mc = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: {
    stiffness: 0.22,
    damping: 0.14,
    render: { visible: false }
  }
});
Composite.add(engine.world, mc);

// Allow normal page scrolling: do not block wheel/touch by default
if (mc.mouse.element) {
  // Defensive: ensure we never preventDefault wheel/touch implicitly
  mc.mouse.element.style.touchAction = 'auto';
}

            // Track dragging bodies so clicks during a drag don't trigger play()
            var dragging = new Set();
            window.__draggingBodies = dragging;

            Events.on(mc, "startdrag", function (e) {
              if (e && e.body) dragging.add(e.body);
            });
            Events.on(mc, "enddrag", function (e) {
              if (e && e.body) dragging.delete(e.body);
            });

            // Scroll impulse → push cards in scroll direction
            var lastY = window.scrollY;
            addEventListener(
              "scroll",
              function () {
                var dy = window.scrollY - lastY;
                lastY = window.scrollY;
                if (!dy) return;

                // Magnify effect based on scroll speed
                var mag = Math.min(40, Math.abs(dy) * 0.6);
                var signY = dy > 0 ? 1 : -1;

                bodies.forEach(function (b) {
                  var bx = b.body.position.x,
                    by = b.body.position.y;

                  // Stronger directional push + a bit of sideways randomness
                  var fx = (Math.random() - 0.5) * 0.02 * mag * 1e-3;
                  var fy = signY * 0.025 * mag * 1e-3;
                  Matter.Body.applyForce(
                    b.body,
                    { x: bx, y: by },
                    { x: fx, y: fy }
                  );

                  // Spin it a little
                  b.body.angularVelocity +=
                    (Math.random() - 0.5) * 0.06 * (mag / 12);
                });

                // Short turbulence burst so it feels “shaken”
                jostle(260, Math.min(2.4, 0.6 + mag / 18));
              },
              { passive: true }
            );

            // Desktop wheel adds extra oomph (high-res delta)
            addEventListener(
              "wheel",
              function (e) {
                var dy = e.deltaY || 0;
                if (!dy) return;
                var mag = Math.min(60, Math.abs(dy) * 0.35);
                var signY = dy > 0 ? 1 : -1;

                bodies.forEach(function (b) {
                  var fx = (Math.random() - 0.5) * 0.03 * mag * 1e-3;
                  var fy = signY * 0.03 * mag * 1e-3;
                  Matter.Body.applyForce(b.body, b.body.position, {
                    x: fx,
                    y: fy,
                  });
                  b.body.angularVelocity +=
                    (Math.random() - 0.5) * 0.08 * (mag / 18);
                });
                jostle(300, Math.min(3, 0.8 + mag / 20));
              },
              { passive: true }
            );

            // Touch drag = jostle as you scroll with your finger
            addEventListener(
              "touchmove",
              function (e) {
                var touches = e.touches;
                if (!touches || !touches[0]) return;
                // approximate swipe speed using movement of the first touch
                // (we don't have previous coords here, so just trigger a mild jostle)
                jostle(240, 1.2);
              },
              { passive: true }
            );

            // Headless render: copy body transforms to DOM
            function render() {
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i];
                var x = b.body.position.x - b.w / 2;
                var y = b.body.position.y - b.h / 2;
                var a = b.body.angle;
                var t =
                  "translate3d(" +
                  x.toFixed(1) +
                  "px," +
                  y.toFixed(1) +
                  "px,0) rotate(" +
                  a.toFixed(3) +
                  "rad)";
                b.el.style.transform = t;
                // keep them above content while floating
                b.el.style.zIndex = "8600";
              }
              ticking = requestAnimationFrame(render);
            }

            // Resize walls on viewport resize
            var onResize = function () {
              // remove old walls
              var comps = Composite.allBodies(engine.world).filter(function (
                b
              ) {
                return b.label === "wall";
              });
              comps.forEach(function (w) {
                Composite.remove(engine.world, w);
              });
              // add new walls
              var W = innerWidth,
                H = innerHeight,
                T = 120;
              var walls = [
                Bodies.rectangle(W / 2, -T / 2, W + T * 2, T, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(W / 2, H + T / 2, W + T * 2, T, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(-T / 2, H / 2, T, H + T * 2, {
                  isStatic: true,
                  restitution: 0.95,
                }),
                Bodies.rectangle(W + T / 2, H / 2, T, H + T * 2, {
                  isStatic: true,
                  restitution: 0.95,
                }),
              ];
              walls.forEach(function (w) {
                w.label = "wall";
                Composite.add(engine.world, w);
              });
            };
            addEventListener("resize", onResize);

            runner = Runner.create();
            Runner.run(runner, engine);
            render();

            // Perpetual wander: each card has a heading vector that slowly
            // drifts. We push along heading + tiny noise so motion feels
            // one-directional and natural.
            Events.on(engine, 'beforeUpdate', function(ev){
              var dt = (ev.delta || 1000/60) / 1000; // seconds
              __idleT += dt;
              var TAU = Math.PI * 2;
              for (var i = 0; i < bodies.length; i++){
                var bd = bodies[i].body;
                if (!bd.__wander){
                  // heading angle, speed scalar, and a timer for small course changes
                  bd.__wander = {
                    ang: Math.random() * Math.PI * 2,
                    speed: 0.00042 + Math.random() * 0.00038,
                    turnTimer: 0.8 + Math.random() * 1.4
                  };
                }
                var w = bd.__wander;
                // occasionally perturb heading a little so paths diverge
                w.turnTimer -= dt;
                if (w.turnTimer <= 0){
                  w.ang += (Math.random() - 0.5) * 0.6; // small course change
                  w.speed = Math.max(0.00025, Math.min(0.0009, w.speed + (Math.random()-0.5)*0.00025));
                  w.turnTimer = 0.8 + Math.random() * 1.6;
                }
                var fx = Math.cos(w.ang) * w.speed + (Math.random()-0.5)*0.00002;
                var fy = Math.sin(w.ang) * w.speed + (Math.random()-0.5)*0.00002;
                Matter.Body.applyForce(bd, bd.position, { x: fx, y: fy });
                // Slight continuous spin, gentler than before
                var targetSpin = 0.02 * (Math.random() > 0.5 ? 1 : -1);
                if (Math.abs(bd.angularVelocity) < 0.06){
                  bd.angularVelocity += targetSpin * dt;
                }
                // Independent idle drift (per-card seeds + per-card time offset)
                if (bd.__idle){
                  var s = bd.__idle;
                  var localT = __idleT + (s.t0 || 0); // de-sync timelines per card

                  // sinusoidal micro-forces with unique freq & phase per axis
                  var fxIdle = Math.sin(TAU * s.fx * localT + s.px) * s.ax;
                  var fyIdle = Math.sin(TAU * s.fy * localT + s.py) * s.ay;

                  Matter.Body.applyForce(bd, bd.position, { x: fxIdle, y: fyIdle });

                  // ambient vector field (very gentle, position + time dependent)
                  var vfx = Math.sin((bd.position.y * 0.002) + __idleT * 0.15) * 0.00008;
                  var vfy = Math.cos((bd.position.x * 0.002) - __idleT * 0.12) * 0.00008;
                  Matter.Body.applyForce(bd, bd.position, { x: vfx, y: vfy });

                  // tiny continuous orientation wander so cards gently rotate even at rest
                  var rotNudge = Math.sin(TAU * (s.fx * 0.42) * localT + s.px * 0.37) * 0.00003;
                  bd.torque += rotNudge;
                }
              }
            });

            // Cursor magnet: sticky, local attraction only when hovering a card
            (function(){
              var mx = 0, my = 0, hasMouse = false;
              document.addEventListener('mousemove', function(e){ mx = e.clientX; my = e.clientY; hasMouse = true; }, {passive:true});

              function metaForBody(bd){
                for (var i=0;i<bodies.length;i++){
                  if (bodies[i].body === bd) return bodies[i];
                }
                return null;
              }

              Events.on(engine, 'afterUpdate', function(){
                if (!hasMouse || !bodies.length) return;

                // find nearest card center
                var nearest = null, bestD2 = Infinity;
                for (var i=0;i<bodies.length;i++){
                  var bd = bodies[i].body;
                  var dx = mx - bd.position.x;
                  var dy = my - bd.position.y;
                  var d2 = dx*dx + dy*dy;
                  if (d2 < bestD2){ bestD2 = d2; nearest = bd; }
                }
                if (!nearest) return;

                var meta = metaForBody(nearest);
                if (!meta) return;

                // Only attract when cursor is essentially "hovering" the card:
                // use a radius equal to ~the card size (half the diagonal).
                var halfDiag = 0.5 * Math.sqrt(meta.w*meta.w + meta.h*meta.h);
                var radius = Math.max(halfDiag * 0.9, 60); // sticky only when close
                if (bestD2 > radius*radius) return;

                // Small pull so it feels sticky, not grabby
                var d = Math.sqrt(bestD2);
                var pull = 0.000035 * (1 - (d / radius)); // weaker and very local
                var fx = (mx - nearest.position.x) * pull;
                var fy = (my - nearest.position.y) * pull;
                Matter.Body.applyForce(nearest, nearest.position, {x: fx, y: fy});
              });
            })();

            // Impacts add spin; also free inertia after first bounce for natural rotation
            Events.on(engine, "collisionStart", function (evt) {
              var pairs = evt.pairs || [];
              for (var i = 0; i < pairs.length; i++) {
                var a = pairs[i].bodyA,
                  b = pairs[i].bodyB;

                [a, b].forEach(function (body) {
                  if (body.label && String(body.label).indexOf("card-") === 0) {
                    if (body.inertia === Infinity) {
                      // allow rotation after first hit
                      Matter.Body.setInertia(
                        body,
                        (body.mass *
                          Math.max(40, body.bounds.max.x - body.bounds.min.x) **
                            2) /
                          12
                      );
                    }
                    body.angularVelocity += (Math.random() - 0.5) * 0.12; // much subtler spin-on-impact
                  }
                });
              }
            });
          }

          function start() {
            if (ACTIVE) return;
            ACTIVE = true;
            document.documentElement.classList.add("float-on");
            buildWorld();
          }

          // Expose to Party toggle
          window.__startFloatMode = start;
        })();

        /* Reveal (replayable) */
        var els = [].slice.call(document.querySelectorAll("[data-animate]"));
        if ("IntersectionObserver" in window) {
          try {
            var io = new IntersectionObserver(
              function (entries) {
                for (var i = 0; i < entries.length; i++) {
                  var e = entries[i];
                  if (e.isIntersecting) e.target.classList.add("reveal");
                  else e.target.classList.remove("reveal");
                }
              },
              { rootMargin: "0px 0px -10% 0px", threshold: 0.1 }
            );
            els.forEach(function (el) {
              io.observe(el);
            });
          } catch (_) {
            els.forEach(function (el) {
              el.classList.add("reveal");
            });
          }
        } else {
          els.forEach(function (el) {
            el.classList.add("reveal");
          });
        }

        /* Drift (global) */
        var driftNodes = [].slice.call(
          document.querySelectorAll("[data-parallax],[data-drift]")
        );
        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }
        function driftTick() {
          var vh = window.innerHeight || 1;
          var sc = d.scrollTop || b.scrollTop;
          var rawScale = getComputedStyle(d)
            .getPropertyValue("--drift-scale")
            .trim();
          var scale = parseFloat(rawScale);
          if (isNaN(scale)) scale = 1;

          for (var i = 0; i < driftNodes.length; i++) {
            var el = driftNodes[i];
            var multY = parseFloat(el.getAttribute("data-drift"));
            if (!(multY || multY === 0))
              multY = el.hasAttribute("data-parallax") ? 1.2 : 0.7;
            var multX = parseFloat(el.getAttribute("data-drift-x"));
            if (!(multX || multX === 0)) multX = 0.55 * multY;

            var r = el.getBoundingClientRect();
            var center = r.top + r.height / 2;
            var norm = (center - vh / 2) / vh;

            // Stronger, more obvious drift (tunable via --drift-scale and Lab)
            var y = clamp(-60 * norm * multY * scale, -90, 90);
            var x = Math.sin(sc * 0.006 + i * 0.9) * (22 * multX * scale);

            el.style.setProperty("--dy", y + "px");
            el.style.setProperty("--dx", x + "px");
          }
          requestAnimationFrame(driftTick);
        }
        requestAnimationFrame(driftTick);

        /* Scroll progress */
        var bar = document.getElementById("scroll-progress");
        function progress() {
          var sc = d.scrollTop || b.scrollTop,
            max = d.scrollHeight - d.clientHeight || 1;
          if (bar) bar.style.width = (sc / max) * 100 + "%";
        }
        progress();
        document.addEventListener("scroll", progress, { passive: true });

        /* Mobile nav toggle */
        (function () {
          var nav = document.getElementById("nav");
          var btn = document.getElementById("nav-toggle");
          if (!nav || !btn) return;
          btn.addEventListener("click", function () {
            nav.classList.toggle("open");
          });
        })();

        /* Detect touch / coarse pointer for mobile behavior */
        var IS_COARSE =
          window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
        // Soften drift and thicken morph on mobile/tablet
        d.style.setProperty("--drift-scale", IS_COARSE ? 0.75 : 1.0);
        d.style.setProperty("--morph-stroke-min", IS_COARSE ? 16 : 22);
        d.style.setProperty("--morph-stroke-max", IS_COARSE ? 28 : 36);
        // ensure a default color exists so Lab can read/override
        if (
          !getComputedStyle(d).getPropertyValue("--morph-stroke-color").trim()
        ) {
          d.style.setProperty("--morph-stroke-color", "#7dd3fc");
        }

        /* Konami Party Mode ++ (revived + personal lab) */
        (function () {
          var root = document.documentElement;

          function toggleParty() {
            var root = document.documentElement;
            var wrap = document.querySelector(".morph-wrap");
            var frame = document.querySelector(".content-frame");

            root.classList.toggle("party");
            if (root.classList.contains("party")) {
              if (window.__startFloatMode) window.__startFloatMode();
            }

            if (!wrap || !frame) return;

            if (root.classList.contains("party")) {
              // Move morph out of the filtered/animated .content-frame so it
              // stays truly viewport-fixed and doesn’t jump to the top.
              document.body.appendChild(wrap);
              // Ensure stacking & centering
              wrap.style.position = "fixed";
              wrap.style.left = "0";
              wrap.style.right = "0";
              wrap.style.top = "50vh";
              wrap.style.transform = "translateY(-50%)";
              wrap.style.zIndex = "7000"; // below grain (8000) and lab (9000)
            } else {
              // Put it back as the first child of the content column
              frame.insertBefore(wrap, frame.firstChild);
              // Let CSS rules take over again
              wrap.style.position = "";
              wrap.style.left = "";
              wrap.style.right = "";
              wrap.style.top = "";
              wrap.style.transform = "";
              wrap.style.zIndex = "";
            }
          }

          // ===== Secret Triggers: Triple‑Tap and Shake Only =====
          (function () {
            var lastTaps = []; // store recent touchend timestamps (ms)
            var TAP_WINDOW = 600; // 3 taps within 600ms
            var lastTouchX = 0,
              lastTouchY = 0,
              moved = false;

            // Helper: only count taps that didn't move much (avoid scroll flings)
            function onTouchStart(e) {
              moved = false;
              if (e.touches && e.touches[0]) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
              }
            }
            function onTouchMove(e) {
              if (!e.touches || !e.touches[0]) return;
              var dx = Math.abs(e.touches[0].clientX - lastTouchX);
              var dy = Math.abs(e.touches[0].clientY - lastTouchY);
              if (dx + dy > 12) moved = true;
            }
            function onTouchEnd(e) {
              if (moved) return; // not a tap
              var now = Date.now();
              lastTaps.push(now);
              // keep only taps in the window
              while (lastTaps.length && now - lastTaps[0] > TAP_WINDOW)
                lastTaps.shift();
              if (lastTaps.length >= 3) {
                lastTaps.length = 0; // reset
                toggleParty();
              }
            }

            document.addEventListener("touchstart", onTouchStart, {
              passive: true,
            });
            document.addEventListener("touchmove", onTouchMove, {
              passive: true,
            });
            document.addEventListener("touchend", onTouchEnd, {
              passive: true,
            });

            // ===== Shake to toggle (with iOS permission gate) =====
            function enableShake() {
              var shaking = false;
              window.addEventListener("devicemotion", function (e) {
                var a = e.accelerationIncludingGravity || e.acceleration;
                if (!a) return;
                // tune threshold: ~ heavy jolt
                var mag =
                  Math.abs(a.x || 0) + Math.abs(a.y || 0) + Math.abs(a.z || 0);
                if (mag > 55) {
                  if (!shaking) {
                    shaking = true;
                    toggleParty();
                    setTimeout(function () {
                      shaking = false;
                    }, 1600);
                  }
                }
              });
            }

            // Request permission on iOS 13+; otherwise just enable
            if (
              typeof DeviceMotionEvent !== "undefined" &&
              typeof DeviceMotionEvent.requestPermission === "function"
            ) {
              // try once after a user gesture (first tap)
              var asked = false;
              function ask() {
                if (asked) return;
                asked = true;
                DeviceMotionEvent.requestPermission()
                  .then(function (res) {
                    if (res === "granted") enableShake();
                  })
                  .catch(function () {});
                document.removeEventListener("touchend", ask, {
                  passive: true,
                });
              }
              document.addEventListener("touchend", ask, { passive: true });
            } else if (window.DeviceMotionEvent) {
              enableShake();
            }
          })();

          // Expose for other scripts (optional)
          window.__toggleParty = toggleParty;

          /* DEV ONLY: local keyboard toggles for Party Mode */
          (function () {
            var isLocal =
              location.hostname === "localhost" ||
              location.hostname === "127.0.0.1";
            if (!isLocal) return;

            // Press "K" to toggle Party Mode locally
            addEventListener("keydown", function (e) {
              var key = (e.key || "").toLowerCase();
              if (key === "k") {
                toggleParty();
              }
            });
          })();

          // Global Konami code (desktop & mobile keyboards)
          (function () {
            // Normalize keys to strings so Safari/Firefox/Chromium all agree
            var buf = [];
            var KONAMI = [
              "ArrowUp",
              "ArrowUp",
              "ArrowDown",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              "ArrowLeft",
              "ArrowRight",
              "b",
              "a",
            ];
            function pushKey(k) {
              buf.push(k);
              if (buf.length > KONAMI.length) buf.shift();
              for (var i = 0; i < KONAMI.length; i++) {
                if (buf[i] !== KONAMI[i]) return false;
              }
              return true;
            }
            // listen on document to ensure we get keys even when body is scrolled
            document.addEventListener(
              "keydown",
              function (e) {
                // ignore when typing in form fields or contenteditable
                var t = e.target;
                if (
                  t &&
                  (t.isContentEditable ||
                    /input|textarea|select|button/i.test(t.tagName))
                )
                  return;

                var k = (e.key || "").toString();
                // legacy fallback if a browser fails to provide e.key
                if (!k && typeof e.keyCode === "number") {
                  var map = {
                    37: "ArrowLeft",
                    38: "ArrowUp",
                    39: "ArrowRight",
                    40: "ArrowDown",
                    65: "a",
                    66: "b",
                  };
                  k = map[e.keyCode] || "";
                }
                if (!k) return;

                if (pushKey(k)) {
                  if (window.__toggleParty) window.__toggleParty();
                  buf.length = 0; // reset after success
                }
              },
              false
            );
          })();
        })();

        /* VHS tracking lines (only when html.party is active) */
        (function(){
          var cvs = document.getElementById('grain');
          if (!cvs) return;
          var ctx = cvs.getContext('2d');
          function size(){ cvs.width = innerWidth; cvs.height = innerHeight; }
          size(); addEventListener('resize', size);

          var t = 0, tearTimer = 0, tearY = 0;
          var coarse = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || 'ontouchstart' in window;
          var fps = coarse ? 30 : 48;
          var last = performance.now();

          function band(y, h, amp, rgbShift){
  var w = cvs.width;
  // optional RGB split
  var channels = rgbShift ? [ [255,40,40,0], [40,255,40,1], [40,120,255,2] ] : [ [220,220,220,0] ];
  channels.forEach(function(ch){
    var r=ch[0], g=ch[1], b=ch[2], phase=ch[3];
    var img = ctx.createImageData(w, h);
    var data = img.data;
    for (var x = 0; x < w; x++){
      var shift = Math.floor((Math.sin((x*0.035) + t*0.6 + phase) * 0.5 + 0.5) * amp);
      for (var yy = 0; yy < h; yy++){
        var nx = (x + shift + w) % w;
        var idx = (yy * w + nx) * 4;
        data[idx]   = r;
        data[idx+1] = g;
        data[idx+2] = b;
        data[idx+3] = 170; // semi-opaque
      }
    }
    ctx.putImageData(img, 0, y);
  });
}

          function frame(now){
            if (!document.documentElement.classList.contains('party')){
              requestAnimationFrame(frame); return;
            }
            var dt = now - last;
            if (dt < 1000/fps){ requestAnimationFrame(frame); return; }
            last = now; t += dt*0.001;

            ctx.clearRect(0,0,cvs.width,cvs.height);

// Dark veil + subtle vertical chroma noise
ctx.fillStyle = 'rgba(0,0,0,0.2)';
ctx.fillRect(0,0,cvs.width,cvs.height);
for (var vx = 0; vx < cvs.width; vx += 3){
  var k = (Math.sin(vx*0.05 + t*3.0) * 0.5 + 0.5) * 18|0;
  ctx.fillStyle = 'rgba(' + (k+10) + ',' + (k) + ',' + (k+24) + ',0.08)';
  ctx.fillRect(vx, 0, 1, cvs.height);
}

// Heavy head-switching band near the bottom with RGB split
var H = cvs.height;
var bandH = Math.max(10, Math.floor(H * 0.04));
var yBottom = Math.floor(H * (0.82 + 0.12*Math.sin(t*0.9)));
band(yBottom, bandH, 22, true);

// Two mid-frame jitter bands
band(Math.floor(H * 0.30), 4, 14, false);
band(Math.floor(H * 0.58), 3, 12, false);

// Frequent tearing line that zips by
tearTimer -= dt*0.001;
if (tearTimer <= 0){
  tearTimer = 0.6 + Math.random()*1.2;
  tearY = Math.floor(H * Math.random());
}
band(Math.max(0, tearY - 3), 6, 28, true);

            // a couple of faint mid-frame jitter bands
            band(Math.floor(cvs.height * 0.33), 2, 10);
            band(Math.floor(cvs.height * 0.62), 2, 8);

            requestAnimationFrame(frame);
          }
          requestAnimationFrame(frame);
        })();

        /* CONTINUOUS WAVE MORPH (centered, section-aware, audio-capable) */
        (function initWave() {
          var host = document.getElementById("morph-svg");
          if (!host) return;

          function vw() {
            return Math.max(
              1,
              window.innerWidth || document.documentElement.clientWidth || 1
            );
          }
          var W = vw(); // full viewport width
          var H = Math.max(360, innerHeight); // generous height
          // Hard-apply 100vw width on the host wrapper as an extra override
          var wrap = document.querySelector(".morph-wrap");
          if (wrap) {
            wrap.style.width = "100vw";
            wrap.style.left = "0";
            wrap.style.right = "0";
          }
          var midY = H / 2;
          var xStart = 0;
          var xEnd = W;

          var svgNS = "http://www.w3.org/2000/svg";
          var svg = document.createElementNS(svgNS, "svg");
          svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          svg.setAttribute("preserveAspectRatio", "none");

          var outline = document.createElementNS(svgNS, "path");
          outline.setAttribute("fill", "none");
          outline.setAttribute("stroke", "rgba(0,0,0,0.28)");
          outline.setAttribute("stroke-linecap", "round");
          outline.setAttribute("stroke-linejoin", "round");
          svg.appendChild(outline);

          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "currentColor");
          path.setAttribute("stroke-linecap", "round");
          path.setAttribute("stroke-linejoin", "round");
          path.setAttribute("data-blend", ""); // lets CSS var color win
          svg.appendChild(path);
          host.innerHTML = "";
          host.appendChild(svg);

          var root = document.documentElement;
          function readNumVar(name, fallback) {
            var v = parseFloat(getComputedStyle(root).getPropertyValue(name));
            return isNaN(v) ? fallback : v;
          }
          function strokeMin() {
            return readNumVar("--morph-stroke-min", 9);
          }
          function strokeMax() {
            return readNumVar("--morph-stroke-max", 13);
          }
          function strokeColor() {
            var c = getComputedStyle(root)
              .getPropertyValue("--morph-stroke-color")
              .trim();
            return c || "#7dd3fc";
          }
          path.style.stroke = strokeColor();
          path.style.mixBlendMode = "screen";
          path.style.strokeOpacity = "1";
          outline.setAttribute("stroke-opacity", "0.18");
          path.style.opacity = "0.70";
          path.setAttribute("stroke-width", strokeMin());

          // === Wave parameters (full-bleed across viewport) ===
          var cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4))); // target 4 undulations
          var k = (Math.PI * 2 * cycles) / (xEnd - xStart); // frequency across the whole width
          var phase = 0;
          var speed = readNumVar("--wave-speed", 0.0018); // +50% speed for snappier motion
          var amp = Math.min(H * 0.42, 340); // slightly lower amplitude; bigger, slower waves
          // sample density: about one point per pixel, with a floor for small screens
          var N = Math.max(1200, Math.floor((xEnd - xStart) * 1.0));

          // Section → waveform map
          var targetShape = "sine";
          var sectionMap = [
            ["hero", "sine"],
            ["about", "square"],
            ["services", "triangle"],
            ["work", "saw"],
            ["contact", "static"],
          ];
          if ("IntersectionObserver" in window) {
            var io = new IntersectionObserver(
              function (entries) {
                entries.forEach(function (e) {
                  if (e.isIntersecting) {
                    for (var i = 0; i < sectionMap.length; i++) {
                      if (e.target.id === sectionMap[i][0]) {
                        targetShape = sectionMap[i][1];
                        break;
                      }
                    }
                  }
                });
              },
              { threshold: 0.55 }
            );
            sectionMap.forEach(function (pair) {
              var el = document.getElementById(pair[0]);
              if (el) io.observe(el);
            });
          }

          // Optional audio analyser (enabled when you play the track)
          var analyser = window.__waveAnalyser || null;
          var buf = analyser ? new Uint8Array(analyser.fftSize) : null;

          function lerp(a, b, t) {
            return a + (b - a) * t;
          }
          function sign(x) {
            return x < 0 ? -1 : 1;
          }
          function toPathD(xs, ys) {
            var d = "M" + xs[0] + "," + ys[0];
            for (var i = 1; i < xs.length; i++) {
              d += " L" + xs[i] + "," + ys[i];
            }
            return d;
          }
          function shapeY(nx, ph, kind) {
            var x = xStart + nx * (xEnd - xStart);
            var t = k * x + ph;
            switch (kind) {
              case "sine":
                return Math.sin(t);
              case "square":
                return sign(Math.sin(t));
              case "triangle":
                return (2 / Math.PI) * Math.asin(Math.sin(t));
              case "saw": {
                var u = (t / (2 * Math.PI)) % 1;
                return 2 * u - 1;
              }
              case "static":
                return (Math.random() * 2 - 1) * 0.15;
              default:
                return Math.sin(t);
            }
          }

          var currentShape = "sine";
          var morphT = 1; // 1 = at current shape, 0 = finished morph to target

          function frame() {
            // keep color + width in sync with CSS vars
            path.style.stroke = strokeColor();
            phase += speed;
            var sw = lerp(
              strokeMin(),
              strokeMax(),
              (Math.sin(phase * 0.5) + 1) / 2
            );
            path.setAttribute("stroke-width", sw.toFixed(2));
            outline.setAttribute("stroke-width", (sw + 2).toFixed(2));
            outline.style.mixBlendMode = "screen";

            // smooth morph when section changes
            if (currentShape !== targetShape) {
              morphT -= 0.06;
              if (morphT <= 0) {
                currentShape = targetShape;
                morphT = 0;
              }
            } else {
              morphT = Math.min(1, morphT + 0.06);
            }

            // optionally use audio (if analyser is present and playing)
            if (window.__waveAnalyser && !analyser) {
              analyser = window.__waveAnalyser;
              buf = new Uint8Array(analyser.fftSize);
            }
            if (analyser) {
              analyser.getByteTimeDomainData(buf);
            }

            var xs = new Array(N),
              ys = new Array(N);
            for (var i = 0; i < N; i++) {
              var nx = i / (N - 1);
              xs[i] = xStart + nx * (xEnd - xStart);

              var base;
              if (analyser) {
                var idx = Math.floor(nx * (buf.length - 1));
                base = (buf[idx] - 128) / 128; // -1..1
              } else {
                base = shapeY(nx, phase, currentShape); // keep exact cycle count
              }

              if (morphT < 1) {
                var toY = shapeY(nx, phase, targetShape);
                base = lerp(toY, base, morphT);
              }

              ys[i] = midY + base * amp;
            }

            outline.setAttribute("d", toPathD(xs, ys));
            path.setAttribute("d", toPathD(xs, ys));
            requestAnimationFrame(frame);
          }
          requestAnimationFrame(frame);

          // Keep centered sizing on resize
          function resync() {
            W = vw();
            H = Math.max(360, innerHeight);
            midY = H / 2;
            xStart = 0;
            xEnd = W;
            cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4)));
            k = (Math.PI * 2 * cycles) / (xEnd - xStart);
            N = Math.max(1200, Math.floor((xEnd - xStart) * 1.0));
            amp = Math.min(H * 0.42, 340);
            svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          }
          addEventListener("resize", resync);
        })();

        /* Footer year */
        var y = document.getElementById("year");
        if (y) y.textContent = new Date().getFullYear();
      })();
    </script>
  </body>
</html>

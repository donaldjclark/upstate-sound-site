<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      document.documentElement.classList.add("js");
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Upstate Sound &amp; Repair ‚Äì Boutique audio service in Greenville, SC
    </title>

    <!-- Fonts + (optional) your external stylesheet -->
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Space+Grotesk:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css?v=4" />
    <!-- Inline favicon to avoid 404 /favicon.ico requests -->
    <link
      rel="icon"
      type="image/svg+xml"
      href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none"%3E%3Crect width="64" height="64" rx="12" fill="%230a0a0a"/%3E%3Cpath d="M6 32c6-10 12 10 18 0s12-10 18 0 12 10 18 0" stroke="%237dd3fc" stroke-width="6" stroke-linecap="round" fill="none"/%3E%3C/svg%3E'
    />
    <link
      rel="shortcut icon"
      href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none"%3E%3Crect width="64" height="64" rx="12" fill="%230a0a0a"/%3E%3Cpath d="M6 32c6-10 12 10 18 0s12-10 18 0 12 10 18 0" stroke="%237dd3fc" stroke-width="6" stroke-linecap="round" fill="none"/%3E%3C/svg%3E'
    />

    <style>
      /* ---------- Page frame / background gutters ---------- */
      :root {
        --bg-x: 50%;
        --bg-y: 50%;
        --bg-pattern-image: url("assets/background-light.svg");
        --bg-overlay: linear-gradient(
          0deg,
          rgba(10, 10, 10, 0.45),
          rgba(10, 10, 10, 0.45)
        );
        --hero-bg-image: var(--bg-pattern-image);
        --hero-overlay-light: linear-gradient(
          180deg,
          rgba(250, 249, 246, 0) 0%,
          rgba(10, 10, 10, 0.08) 45%,
          rgba(10, 10, 10, 0.6) 100%
        );
        --hero-overlay-dark: linear-gradient(
          180deg,
          rgba(19, 30, 54, 0) 0%,
          rgba(12, 18, 32, 0.54) 55%,
          rgba(5, 8, 16, 0.82) 100%
        );
        --hero-overlay: var(--hero-overlay-light);
      }
      html {
        background-image: var(--bg-overlay), var(--bg-pattern-image);
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: cover;
        background-position: var(--bg-x) var(--bg-y);
      }
      html.dark-mode {
        --bg-pattern-image: url("assets/background-dark.svg");
        --hero-bg-image: var(--bg-pattern-image);
        --bg-overlay: linear-gradient(
          0deg,
          rgba(5, 8, 16, 0.5),
          rgba(5, 8, 16, 0.5)
        );
        --morph-stroke-color: #7dd3fc; /* brighter cyan pops on dark */
        --hero-overlay: var(--hero-overlay-dark);
      }
      html.light-mode {
        --morph-stroke-color: #2f6f64;
      }
      html.party {
        --morph-stroke-color: #7dd3fc;
      }
      body {
        margin: 0;
        color: #e6e6e6;
        font-family: "Space Grotesk", system-ui, sans-serif;
        background: transparent;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -1;
        pointer-events: none;
        background-image: var(--bg-overlay), var(--bg-pattern-image);
        background-repeat: no-repeat;
        background-size: cover;
        background-position: var(--bg-x) var(--bg-y);
      }

      :root {
        /* Seafoam glow palette (matches background shapes) */
        --glow-main: 47, 111, 100; /* #2F6F64 */
        --glow-halo: 31, 85, 77; /* a darker teal for the halo */

        /* runtime‚Äëtunable vars */
        --drift-scale: 1;
        --morph-stroke-color: #2f6f64; /* default seafoam */
        --morph-stroke-min: 18;
        --morph-stroke-max: 28;
        --wave-speed: 0.001; /* 50% faster than 0.0006 */
        --wave-cycles: 4; /* number of undulations across the viewport */
        --morph-opacity: 0.24; /* try 0.18 ~ 0.35 */
      }

      /* Content column handles layout while the morph wave floats as a sibling overlay */
      .content-frame {
        position: relative;
        max-width: 1100px;
        margin: 0 auto;
        background: transparent; /* bg moved to ::before so morph can sit above it */
        min-height: 100dvh;
        z-index: 2; /* creates local stacking context */
        overflow: visible;
      }
      .content-frame::before {
        content: "";
        position: fixed; /* fixed so column bg doesn‚Äôt scroll */
        left: 50vw;
        top: 0;
        transform: translateX(-50%);
        width: min(1100px, 92vw);
        height: 100dvh; /* dynamic viewport for iOS bars */
        background: rgba(
          10,
          10,
          10,
          0.92
        ); /* translucent tint only; let single background show through */
        z-index: 0;
      }

      /* iOS Safari: emulate background-attachment: fixed via a fixed body::before layer.
         Mobile Safari ignores/bugs fixed backgrounds on html/body, which causes the
         hero/header to visually slip. This layer pins the image to the viewport. */
      @supports (-webkit-touch-callout: none) {
        html {
          background: transparent !important;
        }
        body::before {
          /* stabilize compositing */
          transform: translateZ(0);
          will-change: transform;
        }
      }

      /* Landscape tablets can crop differently; nudge the image up a bit for alignment */
      @media (orientation: landscape) and (min-width: 900px) and (max-height: 900px) {
        :root {
          --bg-y: 46%;
        }
      }

      /* ===== MORPH: fixed, full-bleed overlay (sits above column background, below content) ===== */
      .morph-wrap {
        position: fixed;
        left: 0 !important;
        right: 0 !important;
        top: 50vh;
        transform: translateY(-50%);
        width: 100vw !important;
        height: 70vh;
        display: block;
        z-index: 60; /* above sections so it‚Äôs never hidden */
        pointer-events: none;
        opacity: 0.24; /* visible but not overpowering */
        mix-blend-mode: screen; /* additive light so it doesn‚Äôt block text */
      }
      .morph-wrap svg {
        width: 100%;
        height: 100%;
        overflow: visible;
        display: block;
      }

      /* Make the morph path obey the CSS var color */
      .morph-wrap svg path[data-blend] {
        stroke: var(--morph-stroke-color, #2f6f64) !important;
      }

      /* Sections / cards: sections have a lower z-index than the morph now */
      .section {
        position: relative;
        z-index: 20;
        padding: 64px 24px;
      }
      .section.alt {
        background: #111;
      }

      h1,
      h2,
      h3 {
        margin: 0 0 16px;
        font-family: "Montserrat", system-ui, sans-serif;
        color: #f4f4f5;
      }
      p {
        color: #c9c9ce;
        line-height: 1.6;
      }

      /* ---------- Header / Hero ---------- */
      #hero {
        position: relative;
        padding: 80px 24px 48px;
        text-align: center;
      }
      .hero-overlay {
        position: absolute;
        inset: 0;
        background: var(--hero-overlay);
        pointer-events: none;
        z-index: 0;
      }
      .logo {
        display: block;
        margin: 0 auto 24px;
        height: auto;
      }

      /* Size inline SVG placed inside .logo container */
      .logo svg {
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto 24px;
      }

      /* Tagline ‚Äútape wobble‚Äù + glow for contrast */
      .tape {
        display: inline-block;
        animation: tapeWobble 1.2s ease-in-out infinite;
        transform-origin: 50% 50%;
      }
      @keyframes tapeWobble {
        0% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
        25% {
          transform: translateY(-1px) rotate(0.22deg) skewX(-0.1deg);
        }
        50% {
          transform: translateY(0.6px) rotate(-0.14deg) skewX(0.06deg);
        }
        75% {
          transform: translateY(-0.8px) rotate(0.18deg) skewX(-0.06deg);
        }
        100% {
          transform: translateY(0) rotate(-0.18deg) skewX(0.12deg);
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .tape {
          animation: none;
        }
      }

      /* Tagline glow (seafoam-only) */
      #hero h1.tape {
        text-shadow: 0 0 3px rgba(var(--glow-main), 0.55),
          0 0 8px rgba(var(--glow-halo), 0.4),
          0 0 16px rgba(var(--glow-main), 0.22);
      }

      .logo {
        isolation: isolate;
      } /* prevent blending weirdness with backdrop */
      .logo svg,
      .logo svg * {
        /* Subtle seafoam glow to match tagline */
        filter: drop-shadow(0 0 2px rgba(var(--glow-main), 0.42))
          drop-shadow(0 0 5px rgba(var(--glow-halo), 0.32))
          drop-shadow(0 0 10px rgba(var(--glow-main), 0.18));
        transition: filter 120ms ease-out;
      }

      /* Nav (desktop/tablet default) */
      #nav {
        position: absolute;
        top: 12px;
        right: 18px;
        display: flex;
        justify-content: flex-end;
        gap: 24px;
        margin-bottom: 12px;
        align-items: center;
      }
      #nav a {
        color: #b9b9ff;
        text-decoration: none;
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      #nav-toggle {
        display: none;
      }

      /* Glitch links */
      a.glitch {
        position: relative;
        display: inline-block;
        text-decoration: none;
      }
      a.glitch::before,
      a.glitch::after {
        content: attr(data-text);
        position: absolute;
        inset: 0;
        opacity: 0;
        mix-blend-mode: screen;
      }
      a.glitch::before {
        color: #22d3ee;
      }
      a.glitch::after {
        color: #a78bfa;
      }
      @keyframes glitchX {
        0% {
          transform: translate(0, 0);
        }
        20% {
          transform: translate(1px, -1px);
        }
        40% {
          transform: translate(-1px, 1px);
        }
        60% {
          transform: translate(2px, 0);
        }
        80% {
          transform: translate(-2px, 1px);
        }
        100% {
          transform: translate(0, 0);
        }
      }
      a.glitch:hover::before,
      a.glitch:hover::after {
        opacity: 0.7;
        animation: glitchX 0.18s steps(2, end) infinite;
      }

      /* Services grid (base = desktop 3 cols) */
      .services-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 28px;
      }
      .service-card {
        background: #f4f2eb;
        color: #142;
        border-radius: 12px;
        padding: 22px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      }
      .service-card.loading {
        cursor: progress;
        opacity: 0.8;
      }
      .service-card.error {
        outline: 2px solid rgba(251, 113, 133, 0.4);
      }
      @media (hover: hover) and (pointer: fine) {
        .service-card:hover {
          outline: 1px solid rgba(255, 255, 255, 0.08);
          transform: translateY(-1px);
          transition: transform 120ms ease-out, outline-color 120ms ease-out;
        }
      }
      .service-card h3 {
        color: #0b2340;
      }
      .service-card p {
        color: #213;
      }

      /* Sticky Services title */
      .services-sticky {
        position: sticky;
        top: 0;
        z-index: 20;
        background: linear-gradient(#0a0a0acc, #0a0a0acc);
        backdrop-filter: blur(4px);
        padding: 10px 24px;
        margin: -10px -24px 16px;
      }

      /* Past work */
      .work-section ul {
        padding-left: 20px;
      }
      .work-section li {
        margin: 12px 0;
      }

      /* Paper panel for About */
      .paper {
        background: #f4f2eb;
        color: #111;
        border-radius: 12px;
        padding: 24px clamp(16px, 2vw, 28px);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.18);
      }
      .paper h2 {
        color: #111;
      }
      .paper p {
        color: #222;
      }

      /* Footer */
      .footer {
        padding: 32px 24px;
        text-align: center;
        color: #aaa;
      }

      /* Reveal + drift (CSS vars written by JS) */
      [data-animate] {
        opacity: 1;
        --revealY: 0px;
        --dy: 0px;
        --dx: 0px;
        transform: translate3d(var(--dx), calc(var(--revealY)+var(--dy)), 0);
      }
      .js [data-animate] {
        opacity: 0;
        --revealY: 24px;
        transition: opacity 0.7s cubic-bezier(0.22, 1, 0.36, 1),
          transform 0.7s cubic-bezier(0.22, 1, 0.36, 1);
        will-change: transform, opacity;
      }
      .reveal {
        opacity: 1 !important;
        --revealY: 0px;
      }

      /* Progress bar */
      #scroll-progress {
        position: fixed;
        inset: 0 auto auto 0;
        height: 3px;
        width: 0%;
        background: linear-gradient(90deg, #22d3ee, #a78bfa);
        z-index: 9999;
      }

      /* ====== PARTY MODE VISUALS (revived) ====== */
      @keyframes hueRoll {
        from {
          filter: hue-rotate(0);
        }
        to {
          filter: hue-rotate(360deg);
        }
      }
      @keyframes slowTilt {
        0% {
          transform: rotate(0.02deg);
        }
        50% {
          transform: rotate(-0.02deg);
        }
        100% {
          transform: rotate(0.02deg);
        }
      }
      @keyframes glowPulse {
        0% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
        50% {
          text-shadow: 0 0 12px rgba(var(--glow-halo), 0.75),
            0 0 26px rgba(var(--glow-main), 0.48);
        }
        100% {
          text-shadow: 0 0 6px rgba(var(--glow-halo), 0.45),
            0 0 16px rgba(var(--glow-main), 0.28);
        }
      }
      /* Richer/faster hue cycle for cards in party (Konami) mode */
      @keyframes hueSpinRich {
        from {
          filter: hue-rotate(0deg) saturate(1) contrast(1.05) brightness(1);
        }
        50% {
          filter: hue-rotate(180deg) saturate(1.7) contrast(1.12)
            brightness(1.06);
        }
        to {
          filter: hue-rotate(360deg) saturate(1) contrast(1.05) brightness(1);
        }
      }
      /* Apply to normal grid cards and floating cards; also colorize during Float Mode */
      /* Float/Party color model: all cards go black; only the playing one glows */
      html.party .flying-card,
      html.float-on .flying-card {
        background: var(--base, #0a0a0a);
        color: #fff;
        filter: none;
        animation: none;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.28);
      }
      html.party .flying-card .title-swap,
      html.float-on .flying-card .title-swap {
        color: #fff;
      }
      html.party .flying-card:not(.playing),
      html.float-on .flying-card:not(.playing) {
        filter: none; /* keep their individual dark base colors visible */
      }
      html.party .flying-card.playing,
      html.float-on .flying-card.playing {
        outline: 2px solid var(--accent, #7dd3fc);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }
      html.party .content-frame::before {
        background: rgba(
          10,
          10,
          10,
          0.85
        ); /* a hair lighter so the RGB bands show through */
      }
      /* Canvas overlay that draws the live waveform on the active card */
      .flying-card .wave,
      .service-card .wave {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        pointer-events: none;
        opacity: 0.85;
        mix-blend-mode: screen;
      }
      /* During launch shrink, disable input */
      .flying-card.no-drag {
        pointer-events: none !important;
      }
      /* Wave should never steal input */
      .flying-card .wave {
        pointer-events: none !important;
      }
      /* Extra emphasis for the currently playing card */
      .flying-card.playing,
      .service-card.playing {
        box-shadow: inset 0 0 0 2px rgba(var(--glow-main), 0.55),
          0 10px 24px rgba(0, 0, 0, 0.28), 0 0 16px rgba(var(--glow-main), 0.32),
          0 0 28px rgba(var(--glow-halo), 0.26);
      }
      /* Brief hold flash when a drag begins */
      html.party .flying-card.held,
      html.float-on .flying-card.held {
        /* Dark inner ring to contrast the bright overlay, plus a subtle accent rim */
        outline: none;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.55),
          /* deeper drop */ inset 0 0 0 3px rgba(0, 0, 0, 0.65),
          /* dark inner ring */ inset 0 0 12px rgba(0, 0, 0, 0.5),
          /* inner dark glow */ 0 0 16px
            color-mix(in srgb, var(--accent, #7dd3fc) 40%, transparent); /* faint accent */
        transition: box-shadow 160ms ease-out;
      }
      html.party .content-frame {
        animation: hueRoll 14s linear infinite;
      }
      html.party .section {
        animation: slowTilt 7s ease-in-out infinite;
      }
      html.party a,
      html.party h1,
      html.party h2,
      html.party h3,
      html.party .reveal {
        animation: glowPulse 1.8s ease-in-out infinite;
      }
      /* Keep the wobble AND add the glow for the tagline */
      html.party #tagline {
        animation: tapeWobble 1.2s ease-in-out infinite,
          glowPulse 1.8s ease-in-out infinite;
      }
      /* Film grain canvas shown only in party-mode */
      #grain {
        position: fixed;
        inset: 0;
        z-index: 8000;
        pointer-events: none;
        opacity: 0.28;
        display: none;
      }
      html.party #grain {
        display: block;
        opacity: 0.42;
      } /* stronger in party */
      /* Symmetric gutter tint in party mode (both left and right) */
      html.party::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 6500; /* above content column bg, below morph (7000) and grain (8000) */
        background: linear-gradient(
          to right,
          rgba(10, 10, 10, 0.38),
          rgba(10, 10, 10, 0) 22%,
          rgba(10, 10, 10, 0) 78%,
          rgba(10, 10, 10, 0.38)
        );
      }
      /* Keep morph centered & viewport-fixed in party/float modes */
      html.party .morph-wrap,
      html.float-on .morph-wrap {
        position: fixed !important;
        top: 50vh !important;
        left: 0 !important;
        right: 0 !important;
        transform: translateY(-50%) !important;
        z-index: 7000 !important; /* below grain (8000) and lab (9000) */
        mix-blend-mode: normal; /* reduce blending cost while floating */
        opacity: 0.18;
      }

      /* Layer that holds drifting cards (fixed, overlays viewport) */
      #float-layer {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 8500;
        pointer-events: none; /* default: no capture */
        display: none; /* hidden until active */
        overflow: visible;
      }
      html.float-on #float-layer,
      html.party #float-layer {
        display: block;
        pointer-events: none; /* overlay never blocks scroll */
        touch-action: manipulation; /* preserve native scrolling */
      }

      /* Keep site navigation interactive above floating layer */
      #nav {
        z-index: 9001; /* above #float-layer (8500) */
        pointer-events: auto;
      }

      /* Avoid expensive background filter while floating (mobile perf) */
      html.party .content-frame::before,
      html.float-on .content-frame::before {
        filter: none !important;
      }

      /* Ensure PIXI overlay never steals input */
      #pixi-overlay {
        pointer-events: none !important;
      }
      canvas.pixi-overlay {
        pointer-events: none !important;
      }
      /* Redundant combo rule to be absolutely safe */
      #pixi-overlay,
      canvas.pixi-overlay {
        pointer-events: none !important;
      }
      /* Root card handles clicks; children do not */
      .flying-card {
        pointer-events: auto !important;
      }
      .flying-card * {
        pointer-events: none !important;
      }

      /* Float Mode (uses the actual six service cards) */
      .flying-card {
        position: absolute; /* inside #float-layer */
        z-index: 1;
        will-change: transform, opacity;
        contain: layout paint;
        backface-visibility: hidden;
        pointer-events: auto; /* clickable for audio */
        transform: translate3d(0, 0, 0);
        transform-origin: center center; /* ensures rotations spin around center */
        left: 0;
        top: 0; /* transform origin is the viewport‚Äôs top-left */
        user-select: none; /* avoid text selection while drifting */
        /* ensure the first paint uses the on-card transform we set from JS */
      }
      /* Ensure the root card is always the single click/drag target and never selects text */
      .flying-card {
        user-select: none;
        -webkit-user-select: none;
        -webkit-user-drag: none;
        -webkit-tap-highlight-color: transparent;
      }
      /* Only the root card handles input so the whole card is reliably clickable */
      .flying-card * {
        pointer-events: none;
      }
      .flying-card .title-swap {
        position: absolute;
        left: 12px;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 700;
        color: #0b2340;
        text-align: center;
        line-height: 1.2;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none; /* prevent accidental selection while floating */
      }
      .flying-card.swap-on .title-swap {
        opacity: 1;
      }
      .flying-card.swap-on h3,
      .flying-card.swap-on p {
        opacity: 0 !important;
        visibility: hidden !important;
        display: none !important;
        height: 0 !important;
        margin: 0 !important;
        pointer-events: none !important;
      }

      /* --- Hover/press lift for floating cards + accessible focus --- */
      html.float-on .flying-card:hover,
      html.party .flying-card:hover {
        z-index: 8700;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.38),
          0 0 18px var(--accent, #7dd3fc);
      }

      html.float-on .flying-card:active,
      html.party .flying-card:active {
        transform: translate3d(var(--fx, 0px), var(--fy, 0px), 0)
          rotate(var(--fa, 0rad)) scale(0.98);
      }

      a:focus-visible,
      button:focus-visible,
      .service-card:focus-visible,
      .flying-card:focus-visible {
        outline: 2px dashed #b9b9ff;
        outline-offset: 3px;
        border-radius: 10px;
      }

      /* === Float launch visuals (size shrink + soft pulse) === */
      /* Quick-change: service cards fly off-stage to the left when Party begins */
      @keyframes flyOutLeft {
        0% {
          transform: translate(0, 0) rotate(0deg) scale(1);
          opacity: 1;
          filter: blur(0);
        }
        60% {
          transform: translate(-26vw, -6vh) rotate(-4deg) scale(0.94);
          opacity: 0.6;
          filter: blur(1px);
        }
        100% {
          transform: translate(-42vw, -8vh) rotate(-8deg) scale(0.88);
          opacity: 0;
          filter: blur(2px);
        }
      }
      .services-section .service-card.vanish {
        animation: flyOutLeft 380ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
        will-change: transform, opacity, filter;
      }
      .flying-card {
        transition: width 320ms cubic-bezier(0.22, 1, 0.36, 1),
          height 320ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 260ms ease;
      }
      .flying-card.launching {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35),
          0 0 0 0 rgba(125, 211, 252, 0);
      }
      .flying-card.launching.playing {
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3),
          0 0 24px var(--accent, #7dd3fc),
          0 0 56px color-mix(in srgb, var(--accent, #7dd3fc) 55%, transparent);
      }

      /* =========================
         RESPONSIVE LAYOUT LAYER
         ========================= */

      /* Tablet (821px‚Äì1099px): 2 columns */
      @media (max-width: 1099px) {
        .services-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      /* =========================
         MOBILE FIX PACK (‚â§ 820px)
         ========================= */
      @media (max-width: 820px) {
        :root {
          --morph-stroke-min: 16;
          --morph-stroke-max: 28;
        }
        :root {
          --drift-scale: 0.75;
        }
        /* Column ‚Äúpaper‚Äù: fill more of the screen but keep gutter image visible */
        .content-frame::before {
          width: min(100vw, 96vw);
          background: rgba(10, 10, 10, 0.95);
        }

        /* Sections: tighter padding for readability */
        .section {
          padding: 40px 18px;
        }

        /* Hero: logo + tagline scale and glow for contrast */
        #hero h1.tape {
          font-size: clamp(22px, 7vw, 36px);
          line-height: 1.08;
          text-shadow: 0 0 4px rgba(var(--glow-main), 0.6),
            0 0 10px rgba(var(--glow-halo), 0.44),
            0 0 18px rgba(var(--glow-main), 0.3);
        }

        /* Nav: real mobile menu (button toggles .open) */
        #nav {
          align-items: center;
          justify-content: space-between;
          gap: 0;
        }
        #nav-toggle {
          display: inline-block;
          font-size: 22px;
          background: transparent;
          color: #b9b9ff;
          border: 0;
        }
        /* collapse links by default */
        #nav .glitch {
          display: none;
          padding: 12px 0;
        }
        #nav .glitch + .glitch {
          border-top: 1px solid rgba(255, 255, 255, 0.06);
        }
        /* show when nav is opened */
        #nav.open .glitch {
          display: block;
        }

        /* Services: single column, bigger touch targets */
        .services-grid {
          grid-template-columns: 1fr;
          gap: 16px;
        }
        .service-card {
          padding: 18px 16px;
          border-radius: 10px;
          box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        }
        .service-card h3 {
          font-size: clamp(18px, 5.2vw, 22px);
        }
        .service-card p {
          font-size: clamp(14px, 4.2vw, 16px);
          line-height: 1.55;
        }

        /* Sticky ‚ÄúServices‚Äù title: less jumpy */
        .services-sticky {
          top: 0;
          padding: 10px 16px;
          margin: -10px -16px 12px;
          background: linear-gradient(#0a0a0acc, #0a0a0acc);
          backdrop-filter: blur(4px);
        }

        /* Past Work spacing */
        .work-section li {
          margin: 10px 0;
        }

        /* Morph: a bit smaller/taller for clarity on phones */
        .morph-wrap {
          width: 100vw;
          height: 55vh;
          opacity: 0.24;
          mix-blend-mode: screen;
        }
        .morph-wrap svg {
          width: 100%;
          height: 100%;
        }

        /* Footer: breathing room */
        .footer {
          padding: 28px 16px;
          font-size: 14px;
        }

        /* Disable keyboard-only hints: Konami is long‚Äëpress / double‚Äëtap on mobile */
        .services-sticky {
          position: sticky;
        } /* keep */
        #grain {
          opacity: 0.22;
        } /* slightly softer on phone */

        /* Thumb-sized floating song cards (mobile only) */
        html.float-on .flying-card,
        html.party .flying-card {
          width: clamp(88px, 22vw, 120px) !important;
          height: clamp(88px, 22vw, 120px) !important;
          padding: 10px !important;
          border-radius: 12px !important;
        }

        html.float-on .flying-card .title-swap,
        html.party .flying-card .title-swap {
          font-size: clamp(10px, 3.4vw, 13px) !important;
          line-height: 1.15 !important;
          left: 6px;
          right: 6px;
        }

        html.float-on .flying-card .wave,
        html.party .flying-card .wave {
          opacity: 0.9;
        }
      }

      /* Ultra-small devices (‚â§ 380px) */
      @media (max-width: 380px) {
        .section {
          padding: 32px 14px;
        }
        .services-sticky {
          margin: -10px -14px 10px;
          padding: 10px 14px;
        }
      }

      /* Dark/Light mode styles */
      body.light-mode {
        background: transparent;
        color: #222;
      }
      body.dark-mode {
        background: transparent;
        color: #eee;
      }
      .theme-toggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        background: none;
        border: 1px solid #ccc;
        border-radius: 20px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 1rem;
        z-index: 1000;
      }
    </style>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <body>
    <!-- Dark/Light mode toggle button -->
    <button class="theme-toggle" aria-label="Toggle dark/light mode">üåô</button>

    <div id="scroll-progress" aria-hidden="true"></div>
    <canvas id="grain" aria-hidden="true"></canvas>
    <audio id="player" preload="metadata" style="display: none"></audio>
    <div id="float-layer" aria-hidden="true"></div>
    <!-- Morph sits above the column background but below content cards -->
    <div class="morph-wrap" aria-hidden="true">
      <div id="morph-svg"></div>
    </div>
    <!-- Content column (bg via ::before) -->
    <div class="content-frame">
      <header id="hero" class="section" data-animate>
        <nav id="nav" data-animate>
          <button id="nav-toggle" aria-label="Toggle navigation">‚ò∞</button>
          <a href="#about" class="glitch" data-text="About" data-animate
            >About</a
          >
          <a href="#services" class="glitch" data-text="Services" data-animate
            >Services</a
          >
          <a href="#work" class="glitch" data-text="Past Work" data-animate
            >Past Work</a
          >
          <a href="#contact" class="glitch" data-text="Contact" data-animate
            >Contact</a
          >
        </nav>

        <div class="hero-overlay"></div>
        <div
          class="logo"
          id="logo-inline"
          aria-label="Upstate Sound &amp; Repair logo"
          data-animate
        ></div>
        <h1 id="tagline" class="tape" data-parallax data-drift="1.2">
          Where Sound Meets Vision.
        </h1>
      </header>

      <main>
        <!-- About -->
        <section id="about" class="section about-section paper" data-animate>
          <h2 data-animate>About</h2>
          <p data-animate>
            Hey, I‚Äôm Donald‚Äîa lifelong chaser of tone and tinkerer of broken
            gear. I‚Äôm an audio engineer, live-sound tech, repair whisperer, and,
            on rare occasions, a musician who actually finishes a song. If
            you‚Äôre here, you probably care about your gear as much as your
            music‚Äîso do I.
          </p>
          <p data-animate>
            Upstate Sound &amp; Repair is my way of keeping our little corner of
            the world humming, one recalcitrant circuit at a time. I consult for
            venues, help artists chase good sound, and I show up when your
            vintage Moog throws a tantrum or your podcast needs a little love.
            If you want work done right (but not uptight), I‚Äôm the guy who shows
            up with a soldering iron, way too many opinions, and a sense of
            humor.
          </p>
        </section>

        <!-- Services -->
        <section
          id="services"
          class="section services-section alt"
          data-animate
        >
          <h2 class="services-sticky" data-animate>Services</h2>
          <div class="services-grid">
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Studio &amp; Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Your studio is only as good as its weakest link. I diagnose and
                repair mixers, preamps, tape machines, and all those vintage
                boxes you can‚Äôt live without. Think of me as your gear‚Äôs
                therapist ‚Äî I listen carefully and I don‚Äôt judge.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Synth &amp; Audio Gear Repair
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Analog synths are living, breathing beasts ‚Äî and they get
                cranky. I service and restore vintage synthesizers, drum
                machines, samplers and outboard gear. Whether it‚Äôs a cracked
                membrane or a blown capacitor, I‚Äôll get the soul back in your
                circuits.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Music Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                I partner with bands and solo artists to produce, record and
                shape their music. From pre-production and arrangement to mixing
                and mastering, I help you capture what you hear in your head and
                translate it to tape. No cookie-cutter templates ‚Äî just honest
                collaboration and sonic exploration.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Podcast Production
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                Have a story to tell? I provide recording, editing and mixing
                for podcasts and audio books. I‚Äôll help you sound like you know
                what you‚Äôre doing ‚Äî crisp vocals, balanced levels, and maybe the
                occasional tasteful synth stab.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Live Sound Engineering
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                From tiny clubs to weird warehouse gatherings, I mix live shows
                that feel like they‚Äôre meant for you. Clean, loud and
                feedback-free. Yes, I‚Äôll carry cases and tape cables because I‚Äôm
                not above grunt work.
              </p>
            </div>
            <div class="service-card" data-animate>
              <h3 data-animate data-drift="1.4" data-drift-x="0.8">
                Consulting &amp; Education
              </h3>
              <p data-animate data-drift="1.8" data-drift-x="1.0">
                One-on-one consulting for studios, bands, and venues.
                Signal-flow bootcamps, mix reviews, live rig sanity checks, and
                hands-on solder sessions. Learn the why, not just the settings.
              </p>
            </div>
          </div>
        </section>

        <!-- Past Work -->
        <section id="work" class="section work-section" data-animate>
          <h2 data-animate>Past Work</h2>
          <ul class="work-list">
            <li data-animate data-drift="0.8">
              <strong>Live &amp; Session Engineer ‚Äì Artis-Naples:</strong>
              engineered recordings for the Naples Philharmonic Orchestra and
              various chamber ensembles at Artis-Naples (home of the Naples
              Philharmonic).
            </li>
            <li data-animate data-drift="0.8">
              <strong>Mix Consultant ‚Äì Swansons Studios:</strong> partnered with
              Britt to fine-tune session mixes for local bands, offering fresh
              ears, technical fixes and workflow hacks.
            </li>
            <li data-animate data-drift="0.8">
              <strong
                >Producer &amp; Mix Engineer ‚Äì 10-Song LP (in progress):</strong
              >
              producing, recording, mixing and mastering a full-length album ‚Äî
              custom synth patches, recorded instruments, a few talk-radio
              samples ‚Äî 100% handcrafted, all original.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Podcast Producer ‚Äì Trailside Carolina:</strong> recorded,
              produced, mixed and mastered the Trailside Carolina podcast ‚Äî
              crystal-clear audio and immersive storytelling for outdoor
              enthusiasts.
            </li>
            <li data-animate data-drift="0.8">
              <strong>Gear Repair Repertoire:</strong> Yamaha DX7/DX7IIFD, CS01,
              CS50/60, SK-20, Microkorg, Lexicon 300, Korg SK1, Kawai K1, Roland
              JP-3000 &amp; RE-201, Ibanez TS-9, Mu-Tron III, Fender Twin
              (reissue), Pro Reverb (1967), Musicman HD-150, ART PRO VLA II, A
              Designs MP-2A‚Ä¶ and many more.
            </li>
          </ul>
        </section>

        <!-- Contact -->
        <section id="contact" class="section contact-section" data-animate>
          <h2 data-animate>Contact</h2>
          <p data-animate>
            Ready to get that crackling amp sorted, record a new podcast or just
            chat about synths? Drop me a line ‚Äî I‚Äôm based in Greenville, South
            Carolina and I love meeting fellow audio nerds.
          </p>
          <p data-animate>
            Email me at
            <a
              class="glitch"
              href="mailto:info@upstatesound.co"
              data-text="info@upstatesound.co"
              >info@upstatesound.co</a
            >.
          </p>
        </section>
      </main>

      <footer class="footer">
        <p>
          ¬© <span id="year"></span> Upstate Sound &amp; Repair. Serving
          Greenville and the Upstate. Made with solder and soul.
        </p>
      </footer>
    </div>
    <!-- .content-frame -->

    <!-- Optional: your existing JS -->
    <script
      src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      // ====== PIXI VHS/CRT OVERLAY (viewport-fixed, no input capture) ======
      (function () {
        // Guard: PIXI must be available
        if (!window.PIXI) {
          window.__pixiVhsReady = false;
          return;
        }

        try {
          // Create a fixed overlay sized to the viewport
          const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundAlpha: 0,
            antialias: false,
            autoDensity: true,
            resolution: window.devicePixelRatio || 1,
          });

          const view = app.view;
          view.id = "pixi-overlay";
          view.className = "pixi-overlay";
          view.style.position = "fixed";
          view.style.inset = "0";
          view.style.zIndex = "8400"; // below Float (#float-layer: 8500)
          view.style.pointerEvents = "none"; // never intercept input
          view.style.display = "none"; // only visible in .party
          view.setAttribute("aria-hidden", "true");
          document.body.appendChild(view);

          // Fullscreen plate we render the filter onto
          const plate = new PIXI.Sprite(PIXI.Texture.WHITE);
          plate.anchor.set(0, 0);
          plate.width = app.renderer.width;
          plate.height = app.renderer.height;
          plate.tint = 0x000000; // base black; color comes from shader
          plate.alpha = 1.0;
          app.stage.addChild(plate);

          // Aggressive VHS/CRT shader:
          //  - rolling scanlines + RGB triad phosphor mask
          //  - chromatic aberration shimmer
          //  - periodic full‚Äëframe warp & horizontal tear bands
          //  - mild barrel distortion / line curl
          //  - animated colored glitch streaks
          // NOTE: This is an OVERLAY; it does not sample page content ‚Äî it paints
          // translucent light/noise over the page to create the CRT look without blocking clicks.
          const frag = `
            precision mediump float;

            uniform float uTime;
            uniform vec2  uRes;
            uniform float uIntensity;  // master 0..1
            uniform float uNoise;      // grain 0..1
            uniform float uCurl;       // barrel strength 0..0.35
            uniform float uTearRate;   // avg seconds between big tears
            uniform float uTriad;      // triad mask strength 0..1
            uniform float uSpeckle;    // white speckle density 0..1
            uniform float uEdgePower;  // right-edge band strength 0..1
            uniform float uBandSpeed;  // rolling band speed
            varying vec2  vTextureCoord;

            // Hash / noise helpers
            float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }
            float noise(vec2 p){
              vec2 i = floor(p), f = fract(p);
              float a = hash(i);
              float b = hash(i + vec2(1.0, 0.0));
              float c = hash(i + vec2(0.0, 1.0));
              float d = hash(i + vec2(1.0, 1.0));
              vec2 u = f*f*(3.0-2.0*f);
              return mix(a, b, u.x) + (c - a)*u.y*(1.0-u.x) + (d - b)*u.x*u.y;
            }

            // Periodic impulses (0..1) ‚Äî used to trigger warps/tears
            float impulse(float t, float period, float width){
              float ph = fract(t / period);
              return smoothstep(0.0, width, ph) * (1.0 - smoothstep(width, width*2.0, ph));
            }

            void main(){
              // Base UV (0..1)
              vec2 uv = vTextureCoord;
              float t = uTime;

              // Mild barrel distortion / line curl
              vec2 centered = (uv - 0.5) * 2.0;          // -1..1
              float r2 = dot(centered, centered);
              float k  = uCurl;                           // ~0.08 default
              centered *= (1.0 + k * r2);
              uv = centered * 0.5 + 0.5;

              // Row-dependent horizontal jitter (tracking instability)
              float row = floor(uv.y * uRes.y);
              float jitter = (hash(vec2(row, floor(t * 24.0))) * 2.0 - 1.0) * (0.0018 + 0.0012 * uIntensity);
              uv.x += jitter;

              // Rolling scanline phase & triad mask
              float scan = 0.6 + 0.4 * sin((uv.y * uRes.y) * 3.14159);
              float tri  = fract(uv.x * uRes.x / 3.0);
              float triad = step(0.66, tri) - step(0.33, tri);
              triad = abs(triad);
              float mask = mix(1.0, mix(0.70, 1.0, triad), clamp(uTriad, 0.0, 1.0));

              // Moving bright band (tracking) + chroma bleed
              float band = smoothstep(0.0, 1.0, 0.5 + 0.5 * sin(t*max(0.01,uBandSpeed) + uv.y*8.0));
              float bandAmt = 0.12 * uIntensity;

              // Fine grain + horizontal jitter noise
              float grains = noise(vec2(uv.x * uRes.x * 0.65, uv.y * uRes.y * 0.18) + t*2.0) - 0.5;
              float jitterRow = noise(vec2(uv.y * 140.0, t * 4.0)) - 0.5;
              float n = grains * (0.55 * uNoise) + jitterRow * (0.35 * uNoise);

              // RGB channel phase offsets (sub-pixel misalignment)
              float shift = (sin(t*0.9) * 0.75 + 1.0) * 0.0028;
              vec3 baseRGB = vec3(
                (scan * (0.82 + 0.18 * sin(t*0.7 + 0.0))) * mask,
                (scan * (0.82 + 0.18 * sin(t*0.8 + 2.1))) * mask,
                (scan * (0.82 + 0.18 * sin(t*0.9 + 4.2))) * mask
              );
              baseRGB += band * bandAmt;

              // Horizontal noise lines drifting upward (VHS scanline interference)
              float hstripe = smoothstep(0.785, 1.0, sin((uv.y - t*0.03) * 46.0));
              hstripe *= (0.16 + 0.12 * uIntensity);
              baseRGB += vec3(0.60, 0.50, 0.70) * hstripe;

              // Noisy right-edge head-switching band (flickery vertical strip)
              float edgeMask = smoothstep(0.985, 0.998, uv.x); // near right edge
              float edgeGrain = noise(vec2(t*3.0, uv.y*260.0)) - 0.5;
              float edgeScan  = sin((uv.y * uRes.y * 0.7 - t * 90.0)); // dense scan shimmer
              float zig = abs(fract(uv.y*22.0 + t*0.4) - 0.5)*2.0; // triangular wave 0..1
              float notches = smoothstep(0.65, 0.98, zig);
              float edgeComb  = clamp(0.6*abs(edgeScan) + 0.8*abs(edgeGrain), 0.0, 1.0) * notches;
              baseRGB += edgeMask * edgeComb * vec3(1.0, 0.96, 0.88) * (0.2 + 0.6*uEdgePower);

              // Sparse white speckles / dropouts
              float sp = hash(vec2(floor(uv.x*uRes.x*0.7)+t*47.0, floor(uv.y*uRes.y*0.7)+t*113.0));
              float speck = step(1.0 - 0.0025*clamp(uSpeckle,0.0,1.0), sp);
              baseRGB += speck * vec3(1.0) * (0.5 + 0.3*uIntensity);

              // Periodic full‚Äëframe wobble (low‚Äëfreq sinusoidal warp)
              float wobble = sin(t * 1.2) * 0.004 * uIntensity;
              baseRGB *= 1.0 + wobble;

              // Horizontal tear band every few seconds (with random height)
              float tearClock = t / max(0.001, uTearRate);         // avg period
              float tearTrig  = impulse(t, uTearRate, 0.12);       // 0..1 spike
              float tearY     = fract(sin(floor(tearClock)) * 43758.5453);
              float tearPos   = mix(0.08, 0.92, tearY);            // 8%..92% down the screen
              float bandWidth = mix(0.006, 0.02, fract(tearY * 17.0));
              float tearBand  = smoothstep(tearPos - bandWidth, tearPos, uv.y) *
                                (1.0 - smoothstep(tearPos, tearPos + bandWidth, uv.y));
              float tearAmp   = 0.18 * tearTrig * uIntensity;
              // Brighten a little and add a colored smear in the band
              baseRGB += tearBand * tearAmp * vec3(1.0, 0.6, 0.9);

              // Vignette to soften edges (CRT glass)
              vec2 d = (uv - 0.5);
              float vign = 1.0 - dot(d, d) * 1.6;
              baseRGB *= clamp(vign, 0.0, 1.0);

              // Apply grain / noise on top
              baseRGB += n * 0.35;

              // Overall alpha ‚Äî keep the site readable
              float alpha = clamp(0.16 + 0.18 * uIntensity, 0.08, 0.42);
              gl_FragColor = vec4(baseRGB, alpha);
            }
          `;

          const uniforms = {
            uTime: 0,
            uRes: new PIXI.Point(app.renderer.width, app.renderer.height),
            uIntensity: 1.0, // 0..1 master
            uNoise: 0.75, // grain strength
            uCurl: 0.085, // barrel/line curl
            uTearRate: 3.5, // seconds between tear events (avg)
            uTriad: 1.0, // strong triad mask
            uSpeckle: 0.35, // some white speckles
            uEdgePower: 0.9, // strong right edge
            uBandSpeed: 0.9, // default band speed
          };

          const filter = new PIXI.Filter(undefined, frag, uniforms);
          plate.filters = [filter];

          // Resize handler keeps everything matched to the viewport
          function fit() {
            const w = Math.max(1, window.innerWidth);
            const h = Math.max(1, window.innerHeight);
            app.renderer.resize(w, h);
            plate.width = w;
            plate.height = h;
            uniforms.uRes.set(w, h);
          }
          window.addEventListener("resize", fit, { passive: true });
          fit();

          // Animate shader time
          app.ticker.add((delta) => {
            uniforms.uTime += delta / 60.0;
          });

          // Toggle visibility with .party on <html>
          function syncVisibility() {
            const on = document.documentElement.classList.contains("party");
            view.style.display = on ? "block" : "none";
          }
          syncVisibility();
          new MutationObserver(syncVisibility).observe(
            document.documentElement,
            {
              attributes: true,
              attributeFilter: ["class"],
            }
          );

          // Optional public knob for future Lab controls
          window.__pixiVhsSet = function (opts) {
            if (!opts) return;
            if (typeof opts.intensity === "number")
              uniforms.uIntensity = Math.max(0, Math.min(1, opts.intensity));
            if (typeof opts.noise === "number")
              uniforms.uNoise = Math.max(0, Math.min(1, opts.noise));
            if (typeof opts.curl === "number")
              uniforms.uCurl = Math.max(0.0, Math.min(0.35, opts.curl));
            if (typeof opts.tearRate === "number")
              uniforms.uTearRate = Math.max(0.8, opts.tearRate);
            if (typeof opts.triad === "number")
              uniforms.uTriad = Math.max(0, Math.min(1, opts.triad));
            if (typeof opts.speckle === "number")
              uniforms.uSpeckle = Math.max(0, Math.min(1, opts.speckle));
            if (typeof opts.edge === "number")
              uniforms.uEdgePower = Math.max(0, Math.min(1, opts.edge));
            if (typeof opts.bandSpeed === "number")
              uniforms.uBandSpeed = Math.max(
                0.01,
                Math.min(6.0, opts.bandSpeed)
              );
          };

          window.__pixiVhsReady = true;
          window.__pixiApp = app;
        } catch (e) {
          console.warn("PIXI VHS overlay failed:", e);
          window.__pixiVhsReady = false;
        }
      })();
    </script>

    <!-- Vibe core -->
    <script>
      (function () {
        var d = document.documentElement,
          b = document.body;

        /* Inline the logo.svg so CSS glow can target its paths */
        (function () {
          // === Waveform rendering on the active card ==========================
          var __waveCard = null,
            __waveCtx = null,
            __waveCvs = null,
            __waveRAF = 0;

          function attachWaveToCard(card) {
            if (!card) return;
            var cvs = card.querySelector(".wave");
            if (!cvs) {
              cvs = document.createElement("canvas");
              cvs.className = "wave";
              card.appendChild(cvs);
            }
            // Ensure overlay behavior regardless of external CSS
            cvs.style.position = "absolute";
            cvs.style.inset = "0";
            cvs.style.width = "100%";
            cvs.style.height = "100%";

            __waveCvs = cvs;
            __waveCtx = cvs.getContext("2d");

            // fit to card box (device-pixel perfect sizing)
            function size() {
              var r = card.getBoundingClientRect();
              var w = Math.max(2, Math.floor(r.width));
              var h = Math.max(2, Math.floor(r.height));
              if (cvs.width !== w) cvs.width = w;
              if (cvs.height !== h) cvs.height = h;
            }
            size();
            // re-fit on next frame (after CSS/layout settles)
            var rafId = requestAnimationFrame(size);
            // track future resizes for responsive cards
            if (window.ResizeObserver) {
              if (cvs.__ro) cvs.__ro.disconnect();
              var ro = new ResizeObserver(size);
              ro.observe(card);
              cvs.__ro = ro;
            } else {
              // fallback: resize on window resize
              if (!cvs.__onResize) {
                cvs.__onResize = size;
                window.addEventListener("resize", size, { passive: true });
              }
            }
            __waveCard = card;
          }

          function stopWave() {
            if (__waveRAF) cancelAnimationFrame(__waveRAF);
            __waveRAF = 0;
            if (__waveCard) {
              var c = __waveCard.querySelector(".wave");
              if (c) {
                c.getContext("2d").clearRect(0, 0, c.width, c.height);
                // cleanup observers/listeners attached in attachWaveToCard
                if (c.__ro) {
                  try {
                    c.__ro.disconnect();
                  } catch (_) {}
                  c.__ro = null;
                }
                if (c.__onResize) {
                  window.removeEventListener("resize", c.__onResize);
                  c.__onResize = null;
                }
              }
              __waveCard.classList.remove("playing");
            }
            __waveCard = null;
          }

          function startWaveOn(card) {
            if (!window.__waveAnalyser || !card) return;
            attachWaveToCard(card);
            card.classList.add("playing");

            var analyser = window.__waveAnalyser;
            var buf = new Uint8Array(analyser.fftSize);

            function draw() {
              if (!__waveCtx || !__waveCvs) return;
              analyser.getByteTimeDomainData(buf);

              var w = __waveCvs.width,
                h = __waveCvs.height;
              var ctx = __waveCtx;
              ctx.clearRect(0, 0, w, h);

              // soft glow trail
              ctx.lineWidth = 3;
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.shadowBlur = 14;
              ctx.shadowColor = "rgba(255,255,255,0.9)";
              ctx.beginPath();

              for (var i = 0; i < buf.length; i++) {
                var x = (i / (buf.length - 1)) * w;
                var y = (buf[i] / 255) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.stroke();
              __waveRAF = requestAnimationFrame(draw);
            }
            stopWave(); // stop previous
            __waveRAF = requestAnimationFrame(draw);
          }
          // Expose waveform helpers globally
          window.__startWaveOn = startWaveOn;
          window.__stopWave = stopWave;
          var holder = document.getElementById("logo-inline");
          if (!holder) return;
          fetch("assets/logo.svg")
            .then(function (r) {
              return r.text();
            })
            .then(function (svg) {
              holder.innerHTML = svg;
            })
            .catch(function (e) {
              console.warn("inline logo failed", e);
            });
        })();

        /* CONTINUOUS WAVE MORPH (centered, section-aware, audio-capable) */
        (function initWave() {
          var host = document.getElementById("morph-svg");
          if (!host) return;

          function vw() {
            return Math.max(
              1,
              window.innerWidth || document.documentElement.clientWidth || 1
            );
          }
          var W = vw();
          var H = Math.max(360, innerHeight);
          var wrap = document.querySelector(".morph-wrap");
          if (wrap) {
            wrap.style.width = "100vw";
            wrap.style.left = "0";
            wrap.style.right = "0";
          }
          var midY = H / 2;
          var xStart = 0;
          var xEnd = W;

          var svgNS = "http://www.w3.org/2000/svg";
          var svg = document.createElementNS(svgNS, "svg");
          svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          svg.setAttribute("preserveAspectRatio", "none");

          var outline = document.createElementNS(svgNS, "path");
          outline.setAttribute("fill", "none");
          outline.setAttribute("stroke", "rgba(0,0,0,0.28)");
          outline.setAttribute("stroke-linecap", "round");
          outline.setAttribute("stroke-linejoin", "round");
          svg.appendChild(outline);

          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "currentColor");
          path.setAttribute("stroke-linecap", "round");
          path.setAttribute("stroke-linejoin", "round");
          path.setAttribute("data-blend", "");
          svg.appendChild(path);
          host.innerHTML = "";
          host.appendChild(svg);

          var root = document.documentElement;
          function readNumVar(name, fallback) {
            var v = parseFloat(getComputedStyle(root).getPropertyValue(name));
            return isNaN(v) ? fallback : v;
          }
          function isFloating() {
            var html = document.documentElement;
            return (
              html.classList.contains("party") ||
              html.classList.contains("float-on")
            );
          }
          function sampleDensity() {
            // Lower path point density while floating for mobile perf
            return isFloating() ? 0.45 : 1.0;
          }
          function strokeMin() {
            return readNumVar("--morph-stroke-min", 9);
          }
          function strokeMax() {
            return readNumVar("--morph-stroke-max", 13);
          }
          function strokeColor() {
            var c = getComputedStyle(root)
              .getPropertyValue("--morph-stroke-color")
              .trim();
            return c || "#2f6f64";
          }
          path.style.stroke = strokeColor();
          path.style.mixBlendMode = "screen";
          path.style.strokeOpacity = "1";
          outline.setAttribute("stroke-opacity", "0.18");
          path.style.opacity = "0.70";
          path.setAttribute("stroke-width", strokeMin());

          // Wave parameters
          var cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4)));
          var k = (Math.PI * 2 * cycles) / (xEnd - xStart);
          var phase = 0;
          var speed = readNumVar("--wave-speed", 0.0018);
          var amp = Math.min(H * 0.42, 340);
          var N = Math.max(420, Math.floor((xEnd - xStart) * sampleDensity()));

          // Section ‚Üí waveform map
          var targetShape = "sine";
          var sectionMap = [
            ["hero", "sine"],
            ["about", "square"],
            ["services", "triangle"],
            ["work", "saw"],
            ["contact", "static"],
          ];
          if ("IntersectionObserver" in window) {
            var io = new IntersectionObserver(
              function (entries) {
                entries.forEach(function (e) {
                  if (e.isIntersecting) {
                    for (var i = 0; i < sectionMap.length; i++) {
                      if (e.target.id === sectionMap[i][0]) {
                        targetShape = sectionMap[i][1];
                        break;
                      }
                    }
                  }
                });
              },
              { threshold: 0.55 }
            );
            sectionMap.forEach(function (pair) {
              var el = document.getElementById(pair[0]);
              if (el) io.observe(el);
            });
          }

          // Optional audio analyser
          var analyser = window.__waveAnalyser || null;
          var buf = analyser ? new Uint8Array(analyser.fftSize) : null;

          function lerp(a, b, t) {
            return a + (b - a) * t;
          }
          function sign(x) {
            return x < 0 ? -1 : 1;
          }
          function toPathD(xs, ys) {
            var d = "M" + xs[0] + "," + ys[0];
            for (var i = 1; i < xs.length; i++) {
              d += " L" + xs[i] + "," + ys[i];
            }
            return d;
          }
          function shapeY(nx, ph, kind) {
            var x = xStart + nx * (xEnd - xStart);
            var tt = k * x + ph;
            switch (kind) {
              case "sine":
                return Math.sin(tt);
              case "square":
                return sign(Math.sin(tt));
              case "triangle":
                return (2 / Math.PI) * Math.asin(Math.sin(tt));
              case "saw": {
                var u = (tt / (2 * Math.PI)) % 1;
                return 2 * u - 1;
              }
              case "static":
                return (Math.random() * 2 - 1) * 0.15;
              default:
                return Math.sin(tt);
            }
          }

          var currentShape = "sine";
          var morphT = 1; // 1=at current, 0=finished morph to target

          var __waveTick = 0;
          function frame() {
            // While floating, update the path every other frame to reduce CPU
            if (isFloating() && ++__waveTick & 1) {
              requestAnimationFrame(frame);
              return;
            }
            path.style.stroke = strokeColor();
            phase += speed;
            var sw = lerp(
              strokeMin(),
              strokeMax(),
              (Math.sin(phase * 0.5) + 1) / 2
            );
            path.setAttribute("stroke-width", sw.toFixed(2));
            outline.setAttribute("stroke-width", (sw + 2).toFixed(2));
            outline.style.mixBlendMode = "screen";

            if (currentShape !== targetShape) {
              morphT -= 0.06;
              if (morphT <= 0) {
                currentShape = targetShape;
                morphT = 0;
              }
            } else {
              morphT = Math.min(1, morphT + 0.06);
            }

            if (window.__waveAnalyser && !analyser) {
              analyser = window.__waveAnalyser;
              buf = new Uint8Array(analyser.fftSize);
            }
            if (analyser) {
              analyser.getByteTimeDomainData(buf);
            }

            var xs = new Array(N),
              ys = new Array(N);
            for (var i = 0; i < N; i++) {
              var nx = i / (N - 1);
              xs[i] = xStart + nx * (xEnd - xStart);
              var base;
              if (analyser) {
                var idx = Math.floor(nx * (buf.length - 1));
                base = (buf[idx] - 128) / 128;
              } else {
                base = shapeY(nx, phase, currentShape);
              }
              if (morphT < 1) {
                var toY = shapeY(nx, phase, targetShape);
                base = lerp(toY, base, morphT);
              }
              ys[i] = midY + base * amp;
            }
            outline.setAttribute("d", toPathD(xs, ys));
            path.setAttribute("d", toPathD(xs, ys));
            requestAnimationFrame(frame);
          }
          requestAnimationFrame(frame);

          function resync() {
            W = vw();
            H = Math.max(360, innerHeight);
            midY = H / 2;
            xStart = 0;
            xEnd = W;
            cycles = Math.max(1, Math.round(readNumVar("--wave-cycles", 4)));
            k = (Math.PI * 2 * cycles) / (xEnd - xStart);
            N = Math.max(420, Math.floor((xEnd - xStart) * sampleDensity()));
            amp = Math.min(H * 0.42, 340);
            svg.setAttribute("viewBox", "0 0 " + W + " " + H);
          }
          addEventListener("resize", resync);
        })();

        /* ===== Audio Unlock (one-time), global helpers ===== */
        (function () {
          var unlocked = false;
          function prime() {
            if (unlocked) return true;
            try {
              var AC = window.AudioContext || window.webkitAudioContext;
              if (!AC) return false;
              var ctx = (window.__audioCtx = window.__audioCtx || new AC());
              // resume context (iOS requires gesture)
              if (ctx.state === "suspended" && ctx.resume) ctx.resume();
              var player = document.getElementById("player");
              if (!player) return false;
              // Connect once to analyser so the waveform always works after first gesture
              if (!window.__waveAnalyser) {
                var srcNode = ctx.createMediaElementSource(player);
                var analyser = ctx.createAnalyser();
                analyser.fftSize = 1024;
                srcNode.connect(analyser);
                analyser.connect(ctx.destination);
                window.__waveAnalyser = analyser;
              }
              // Prime the element by a quick play/pause inside the gesture
              var p = player.play();
              if (p && typeof p.catch === "function") p.catch(function () {});
              player.pause();
              unlocked = true;
              console.log("[audio] context unlocked");
              return true;
            } catch (_) {
              return false;
            }
          }
          window.__primeAudio = prime;
          // One-time capture on first touchend
          var onFirstTouch = function () {
            prime();
            window.removeEventListener("touchend", onFirstTouch, true);
          };
          window.addEventListener("touchend", onFirstTouch, true);
        })();

        /* ====== Party Mode controller (K key + Konami, calls __startFloatMode) ====== */
        (function () {
          // idempotent guard
          if (window.__partyControllerReady) return;
          window.__partyControllerReady = true;

          function enableParty() {
            const html = document.documentElement;
            if (!html.classList.contains("party")) {
              html.classList.add("party");
            }
            // start Float Mode physics if not already running
            if (typeof window.__startFloatMode === "function") {
              window.__startFloatMode();
            }
            // Inject a viewport meta to disable double-tap zoom while allowing pinch
            try {
              var meta = document.querySelector('meta[name="viewport"]');
              if (meta) {
                meta.__orig = meta.getAttribute("content");
                meta.setAttribute(
                  "content",
                  "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=yes"
                );
              }
            } catch (_) {}
          }

          function disableParty() {
            document.documentElement.classList.remove("party");
            if (typeof window.__stopFloatMode === "function") {
              window.__stopFloatMode();
            }
            // Restore original viewport meta
            try {
              var meta = document.querySelector('meta[name="viewport"]');
              if (meta && meta.__orig)
                meta.setAttribute("content", meta.__orig);
            } catch (_) {}
          }

          function toggleParty() {
            if (document.documentElement.classList.contains("party"))
              disableParty();
            else enableParty();
          }

          // Simple 'k' toggle
          window.addEventListener("keydown", function (e) {
            const key = e.key || "";
            if (key.toLowerCase() === "k") {
              e.preventDefault();
              toggleParty();
            }
          });

          // Konami code
          const KONAMI = [
            "ArrowUp",
            "ArrowUp",
            "ArrowDown",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
            "ArrowLeft",
            "ArrowRight",
            "b",
            "a",
          ];
          let idx = 0;
          window.addEventListener("keydown", function (e) {
            const k = e.key || "";
            const key = k.length === 1 ? k.toLowerCase() : k;
            const expect = KONAMI[idx];
            if (
              key === expect ||
              (expect.length === 1 && key === expect.toLowerCase())
            ) {
              idx++;
              if (idx === KONAMI.length) {
                idx = 0;
                enableParty();
              }
            } else {
              // reset smartly if first key of sequence matches current key
              idx = key === KONAMI[0] ? 1 : 0;
            }
          });

          // Mobile secrets: long-press logo to toggle Party
          (function () {
            var isTouch =
              matchMedia("(pointer: coarse)").matches ||
              "ontouchstart" in window;
            if (!isTouch) return;
            var logo = document.getElementById("logo-inline");
            if (!logo) return;
            var t0 = 0,
              id = null,
              startX = 0,
              startY = 0,
              moved = false;
            function clear() {
              if (id) {
                clearTimeout(id);
                id = null;
              }
            }
            logo.addEventListener(
              "touchstart",
              function (e) {
                if (!e.touches || !e.touches[0]) return;
                t0 = performance.now();
                moved = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                clear();
                id = setTimeout(function () {
                  if (!moved) {
                    e.preventDefault();
                    /* gesture qualified */ toggleParty();
                  }
                }, 600);
              },
              { passive: true }
            );
            logo.addEventListener(
              "touchmove",
              function (e) {
                if (!e.touches || !e.touches[0]) return;
                var dx = e.touches[0].clientX - startX,
                  dy = e.touches[0].clientY - startY;
                if (dx * dx + dy * dy > 100) {
                  moved = true;
                  clear();
                }
              },
              { passive: true }
            );
            logo.addEventListener(
              "touchend",
              function () {
                clear();
              },
              { passive: true }
            );
          })();

          // Shake to toggle (with iOS permission + small toast if denied)
          (function () {
            var last = 0,
              debounced = false;
            var TOGGLE_GAP = 1500;
            var SHAKE = 12; // m/s^2 approx
            function tryToggle() {
              var now = Date.now();
              if (now - last > TOGGLE_GAP) {
                last = now;
                toggleParty();
              }
            }
            function onMotion(ev) {
              var a = ev.accelerationIncludingGravity || ev.acceleration || {};
              var ax = a.x || 0,
                ay = a.y || 0,
                az = a.z || 0;
              var mag = Math.sqrt(ax * ax + ay * ay + az * az);
              if (mag > SHAKE) tryToggle();
            }
            function toast(msg) {
              var n = document.createElement("div");
              n.textContent = msg;
              Object.assign(n.style, {
                position: "fixed",
                bottom: "12px",
                left: "50%",
                transform: "translateX(-50%)",
                background: "#111",
                color: "#fff",
                padding: "6px 10px",
                borderRadius: "6px",
                fontSize: "12px",
                opacity: "0.9",
                zIndex: "99999",
              });
              document.body.appendChild(n);
              setTimeout(() => {
                n.remove();
              }, 3000);
            }
            if (typeof DeviceMotionEvent !== "undefined") {
              if (typeof DeviceMotionEvent.requestPermission === "function") {
                // prompt on first user interaction
                window.addEventListener(
                  "touchend",
                  function ask() {
                    DeviceMotionEvent.requestPermission()
                      .then(function (res) {
                        if (res === "granted")
                          window.addEventListener("devicemotion", onMotion, {
                            passive: true,
                          });
                        else toast("Shake disabled");
                      })
                      .catch(function () {
                        toast("Shake disabled");
                      });
                    window.removeEventListener("touchend", ask, true);
                  },
                  true
                );
              } else {
                window.addEventListener("devicemotion", onMotion, {
                  passive: true,
                });
              }
            }
          })();

          // Expose helpers for testing
          window.__partyOn = enableParty;
          window.__partyOff = disableParty;
        })();

        /* === Float Mode (Matter.js orbital drift) ‚Äî unique physics, free rotation, per-card colors === */
        (function () {
          var player = document.getElementById("player");
          var layer = document.getElementById("float-layer");
          if (!layer) {
            layer = document.createElement("div");
            layer.id = "float-layer";
            document.body.appendChild(layer);
          }
          // Appearance is controlled purely via CSS classes (see #float-layer rules)

          // Titles ‚Üî tracks (1:1 with service cards on the page)
          var TITLES = [
            "Resting Place",
            "Deletions of Grandeur",
            "God of No Man",
            "Is There a Number to The Other Side?",
            "Sad News",
            "Spiritually Dead",
          ];
          var TRACKS = [
            "assets/audio/resting-place.m4a",
            "assets/audio/deletions-of-grandeur.m4a",
            "assets/audio/god-of-no-man.m4a",
            "assets/audio/is-there-a-number-to-the-other-side.m4a",
            "assets/audio/sad-news.m4a",
            "assets/audio/spiritually-dead.m4a",
          ];
          // Darker party palette per card
          var BASES = [
            "#0b1f2a",
            "#10231f",
            "#1e1722",
            "#231b10",
            "#122018",
            "#1b2130",
          ];

          // High-contrast accents (used for the playing card + morph stroke)
          var ACCENTS = [
            "#7dd3fc",
            "#a78bfa",
            "#fb7185",
            "#f59e0b",
            "#34d399",
            "#60a5fa",
          ];

          // Matter primitives
          var Engine = window.Matter && Matter.Engine;
          var Bodies = window.Matter && Matter.Bodies;
          var Composite = window.Matter && Matter.Composite;
          var Runner = window.Matter && Matter.Runner;
          var Events = window.Matter && Matter.Events;
          var Mouse = window.Matter && Matter.Mouse;
          var MouseConstraint = window.Matter && Matter.MouseConstraint;
          var engine = null,
            runner = null;
          var __idleT = 0; // seconds since float mode started (for independent idle drift)
          var bodies = []; // {el, body, w, h}
          var ticking = 0;
          var ACTIVE = false;

          // --- Scroll-triggered turbulence (makes things jumble like pebbles) ---
          var burstUntil = 0;
          function jostle(durationMs, power) {
            var now = performance.now();
            burstUntil = Math.max(burstUntil, now + (durationMs || 220));
            if (!power) power = 1;

            function turbulenceFrame() {
              var t = performance.now();
              if (t >= burstUntil) return;
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i].body;
                // lighter small random forces in both axes + a touch of spin
                var fx = (Math.random() - 0.5) * 0.0016 * power;
                var fy = (Math.random() - 0.5) * 0.0016 * power;
                Matter.Body.applyForce(b, b.position, { x: fx, y: fy });
                b.angularVelocity += (Math.random() - 0.5) * 0.028 * power;
              }
              requestAnimationFrame(turbulenceFrame);
            }
            requestAnimationFrame(turbulenceFrame);
          }

          if (player) {
            player.addEventListener(
              "playing",
              function () {
                var card = player.__currentCard;
                if (card) {
                  card.classList.remove("loading", "error");
                  card.classList.add("playing");
                }
              },
              { passive: true }
            );
            ["pause", "ended"].forEach(function (evt) {
              player.addEventListener(
                evt,
                function () {
                  var card = player.__currentCard;
                  if (card) card.classList.remove("loading", "playing");
                },
                { passive: true }
              );
            });
            player.addEventListener(
              "waiting",
              function () {
                var card = player.__currentCard;
                if (card) card.classList.add("loading");
              },
              { passive: true }
            );
            player.addEventListener(
              "error",
              function () {
                var card = player.__currentCard;
                if (card) {
                  card.classList.remove("loading", "playing");
                  card.classList.add("error");
                }
              },
              { passive: true }
            );
          }

          function ensureAnalyser() {
            try {
              if (!window.__waveAnalyser && player) {
                var AC = window.AudioContext || window.webkitAudioContext;
                var ctx = new AC();
                var srcNode = ctx.createMediaElementSource(player);
                var analyser = ctx.createAnalyser();
                analyser.fftSize = 1024;
                srcNode.connect(analyser);
                analyser.connect(ctx.destination);
                window.__waveAnalyser = analyser;
              }
            } catch (_) {}
          }

          function playTrackSrc(src, card) {
            if (!player) return;
            var same = player.src && player.src.endsWith(src);
            if (same && !player.paused) {
              player.pause();
              if (window.__stopWave) window.__stopWave();
              bodies.forEach(function (b) {
                b.el.classList.remove("playing", "loading", "error");
              });
              player.__currentCard = null;
              return;
            }
            if (typeof window.__primeAudio === "function")
              window.__primeAudio();
            if (!same) {
              player.src = src;
              player.load();
            }
            player.__currentCard = card || null;

            // pick a stable accent color by the card's index (fallback cyan)
            var idx = 0;
            if (card) {
              var label = (card.__bodyRef && card.__bodyRef.label) || "";
              var m = /card-(\d+)/.exec(label);
              if (m) idx = +m[1] % ACCENTS.length;
            }
            var acc = ACCENTS[idx] || "#7dd3fc";
            // morph line follows the track‚Äôs accent
            document.documentElement.style.setProperty(
              "--morph-stroke-color",
              acc
            );
            if (card) card.style.setProperty("--accent", acc);
            ensureAnalyser();
            bodies.forEach(function (b) {
              b.el.classList.remove("playing", "loading", "error");
            });
            if (card) {
              card.classList.remove("error");
              card.classList.add("loading");
            }
            if (card && window.__startWaveOn) window.__startWaveOn(card);
            var p = player.play();
            if (p && typeof p.catch === "function")
              p.catch(function (err) {
                console.warn("[audio] play interrupted", err);
              });
          }

          function buildWorld() {
            engine = Engine.create({ enableSleeping: true });
            // Tighten solver to reduce interpenetration
            try {
              engine.positionIterations = 6;
              engine.velocityIterations = 4;
              engine.constraintIterations = 2;
            } catch (_) {}
            engine.gravity.y = 0; // we drive motion with gentle impulses + scroll

            // Full-viewport bounds (thicker, slightly inset, bouncy walls)
            function makeWalls() {
              const W = window.innerWidth;
              const H = window.innerHeight;

              // Wall thickness scales with screen size so bodies can‚Äôt tunnel through.
              const T = Math.max(
                140,
                Math.min(240, Math.round(Math.min(W, H) * 0.08))
              );

              // Tiny inset so we‚Äôre inside the rendered edge (avoids sub-pixel leaks).
              const INSET = 18; // slightly more inset so clicks near edges don't get eaten

              const WALL = {
                isStatic: true,
                restitution: 0.92, // lively bounce
                friction: 0, // don‚Äôt ‚Äústick‚Äù to walls
                frictionStatic: 0,
                frictionAir: 0,
                slop: 0.02, // low overlap tolerance so they never visibly cross
                render: { visible: false },
              };

              const top = Bodies.rectangle(
                W / 2,
                INSET - T / 2,
                W + T * 2,
                T,
                WALL
              );
              const bottom = Bodies.rectangle(
                W / 2,
                H - INSET + T / 2,
                W + T * 2,
                T,
                WALL
              );
              const left = Bodies.rectangle(
                INSET - T / 2,
                H / 2,
                T,
                H + T * 2,
                WALL
              );
              const right = Bodies.rectangle(
                W - INSET + T / 2,
                H / 2,
                T,
                H + T * 2,
                WALL
              );

              [top, bottom, left, right].forEach((w) => {
                w.label = "wall";
                Composite.add(engine.world, w);
              });
            }
            makeWalls();

            // Build bodies out of the six service cards
            var cards = [].slice.call(
              document.querySelectorAll(
                "#services .services-grid .service-card"
              )
            );
            if (!cards.length) return;
            __originalCards = cards.slice();
            __grid = document.querySelector("#services .services-grid");

            var snaps = cards.map(function (card) {
              var r = card.getBoundingClientRect();
              // document-space coordinates (robust against scroll state)
              var docX = r.left + window.scrollX + r.width / 2;
              var docY = r.top + window.scrollY + r.height / 2;
              return {
                card: card,
                docX: docX,
                docY: docY,
                w: r.width,
                h: r.height,
              };
            });

            // Overlay visibility via CSS (.float-on /.party)

            var isCoarse =
              (window.matchMedia &&
                window.matchMedia("(pointer: coarse)").matches) ||
              "ontouchstart" in window;

            bodies = [];
            var cx = innerWidth / 2,
              cy = innerHeight / 2;
            snaps.forEach(function (snap, i) {
              var el = snap.card;

              // 5) Seed a randomized rotation angle variable if not already present
              var initA = Math.random() * Math.PI * 2;

              // Move into overlay and stylize
              layer.appendChild(el);
              el.classList.add("flying-card", "swap-on");
              el.style.position = "absolute";
              el.style.pointerEvents = "auto";
              el.style.background = BASES[i % BASES.length];
              el.style.color = "#fff";
              // Don‚Äôt allow drag/click until the launch shrink is over
              el.classList.add("no-drag");
              el.style.pointerEvents = "none";
              // Hardening for float/flick/tap (prevents text selection and tap highlights)
              el.style.willChange = "transform";
              el.style.userSelect = "none";
              el.style.webkitUserSelect = "none";
              el.style.webkitUserDrag = "none";
              el.style.webkitTapHighlightColor = "transparent";

              // Stage visual continuity: start at the service card's on-page position
              // and its original size, then shrink to the float size with a soft pulse.
              var origW = Math.round(snap.w);
              var origH = Math.round(snap.h);
              el.style.width = origW + "px";
              el.style.height = origH + "px";
              el.style.transformOrigin = "center center";

              // Compute start position in viewport coords (center of original card)
              var startX = 0,
                startY = 0; // temp placeholders; real values set below

              // Centered title only
              var swap = el.querySelector(".title-swap");
              if (!swap) {
                swap = document.createElement("div");
                swap.className = "title-swap";
                el.appendChild(swap);
              }
              swap.textContent = TITLES[i % TITLES.length];
              var h3 = el.querySelector("h3");
              if (h3) {
                var fs = getComputedStyle(h3).fontSize;
                var lh = getComputedStyle(h3).lineHeight;
                swap.style.fontSize = fs;
                if (lh && lh !== "normal") swap.style.lineHeight = lh;
              }
              el.querySelectorAll("h3,p").forEach(function (n) {
                n.style.display = "none";
              });

              // 4) Click/Touch to play (capture; ignore if currently dragging this body)
              (function (trackSrc, cardEl) {
                cardEl.__track = trackSrc;
                cardEl.addEventListener(
                  "click",
                  function (ev) {
                    ev.stopPropagation();
                    // ignore click if Matter thinks we're dragging this body
                    if (
                      window.__draggingBodies &&
                      cardEl.__bodyRef &&
                      window.__draggingBodies.has(cardEl.__bodyRef)
                    ) {
                      return;
                    }
                    // If pointer moved just before up, treat it as drag, not click
                    if (
                      typeof recentPts !== "undefined" &&
                      recentPts.length >= 2
                    ) {
                      var a = recentPts[0];
                      var z = recentPts[recentPts.length - 1];
                      var moved2 =
                        (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
                      if (moved2 > 10 * 10) return; // >10px ‚Üí don‚Äôt trigger play
                    }
                    // Root captures; children are pointer-events:none ‚Äî no extra hit test needed
                    playTrackSrc(cardEl.__track, cardEl);
                  },
                  true
                ); // <-- capture = true so the card gets the click first

                // iOS: gesture-qualified play on touchend (capture)
                cardEl.addEventListener(
                  "touchend",
                  function (ev) {
                    // if we were kinematic dragging, don't treat as play
                    if (cardEl.__bodyRef && cardEl.__bodyRef.__kinDrag) return;
                    // unlock audio context if needed
                    if (typeof window.__primeAudio === "function")
                      window.__primeAudio();
                    // movement threshold via recentPts
                    if (
                      typeof recentPts !== "undefined" &&
                      recentPts.length >= 2
                    ) {
                      var a = recentPts[0];
                      var z = recentPts[recentPts.length - 1];
                      var moved2 =
                        (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
                      if (moved2 > 10 * 10) return;
                    }
                    // This is a qualified tap ‚Üí prevent synthetic click and remember
                    try {
                      ev.preventDefault();
                    } catch (_) {}
                    window.__lastTouchPlayAt = performance.now();
                    playTrackSrc(cardEl.__track, cardEl);
                  },
                  true
                );
              })(TRACKS[i % TRACKS.length], el);

              el.style.touchAction = "none"; // keep this for reliable touch dragging

              // Project document coords into the current viewport so we never all spawn from left
              var viewX = snap.docX - window.scrollX;
              var viewY = snap.docY - window.scrollY;

              // If the Services section is off-screen, fall back to a visible on-screen seed near center
              var inViewX = viewX >= 0 && viewX <= innerWidth;
              var inViewY = viewY >= 0 && viewY <= innerHeight;

              var jitter = 20; // slight randomization so they don't overlap
              var startX, startY;

              if (inViewX && inViewY) {
                startX = viewX + (Math.random() * jitter - jitter / 2);
                startY = viewY + (Math.random() * jitter - jitter / 2);
              } else {
                // seed around center so they never come from off-stage
                startX = innerWidth * (0.45 + Math.random() * 0.1);
                startY = innerHeight * (0.45 + Math.random() * 0.1);
              }

              // Clamp into live area so the first paint is always visible
              var pad = 40;
              startX = Math.max(pad, Math.min(innerWidth - pad, startX));
              startY = Math.max(pad, Math.min(innerHeight - pad, startY));

              // Paint the card exactly over its old spot (transform-only),
              // then we animate the shrink. Keep initial random rotation.
              el.style.transform =
                "translate3d(" +
                (startX - origW / 2).toFixed(1) +
                "px," +
                (startY - origH / 2).toFixed(1) +
                "px,0) rotate(" +
                initA.toFixed(3) +
                "rad)";
              // Freeze the first paint so it doesn't flash at (0,0)
              el.offsetHeight; // force layout

              // Decide float size (mobile = thumb; desktop = 50%) and animate the shrink
              var W = snap.w,
                H = snap.h;
              if (isCoarse) {
                var TW = Math.max(
                  88,
                  Math.min(120, Math.round(innerWidth * 0.22))
                );
                W = H = TW;
              } else {
                W = Math.round(snap.w * 0.5);
                H = Math.round(snap.h * 0.5);
              }

              // Smoothly shrink from original size to float size
              el.style.willChange = "transform,width,height";
              el.classList.add("launching");
              requestAnimationFrame(function () {
                el.style.width = W + "px";
                el.style.height = H + "px";
                // End of launch: re-enable input and sync physics size
                setTimeout(function () {
                  el.classList.remove("launching");
                  el.classList.remove("no-drag");
                  el.style.pointerEvents = "auto"; // drag & click now reliable
                  // Sync physics size to the final DOM size after the shrink
                  try {
                    var cx = body.position.x,
                      cy = body.position.y;
                    Matter.Body.setPosition(body, { x: cx, y: cy });
                    Matter.Body.setVertices(
                      body,
                      Matter.Vertices.fromPath(
                        "0 0 " + W + " 0 " + W + " " + H + " 0 " + H
                      )
                    );
                    Matter.Body.setInertia(
                      body,
                      (body.mass * Math.max(W, H) * Math.max(W, H)) / 12
                    );
                  } catch (_) {}
                }, 420);
              });

              // 3) Create body at original size so picking matches DOM during launch
              var body = Bodies.rectangle(startX, startY, origW, origH, {
                restitution: isCoarse ? 0.7 + Math.random() * 0.15 : 0.6,
                frictionAir: isCoarse
                  ? 0.012 + Math.random() * 0.008
                  : 0.004 + Math.random() * 0.003,
                friction: isCoarse ? 0 : 0.001,
                slop: 0.02,
                density: 0.0008,
                // inertia: Infinity, // REMOVED
                chamfer: { radius: 12 },
                angle: initA,
              });
              body.__idle = {
                // leaf-on-water: slower frequencies + stronger micro-forces
                ax:
                  (0.00042 + Math.random() * 0.00028) * (isCoarse ? 1.2 : 1.0), // x force amplitude
                ay:
                  (0.00042 + Math.random() * 0.00028) * (isCoarse ? 1.2 : 1.0), // y force amplitude
                fx: 0.06 + Math.random() * 0.12, // x frequency (very slow)
                fy: 0.06 + Math.random() * 0.12, // y frequency (very slow)
                px: Math.random() * Math.PI * 2, // x phase
                py: Math.random() * Math.PI * 2, // y phase
                t0: Math.random() * 10.0, // per-card time offset so waves are de-synced
              };
              body.label = "card-" + i;
              Composite.add(engine.world, body);
              bodies.push({ el: el, body: body, w: W, h: H });
              // 4) After pushing to bodies, add cross refs for drag detection
              el.__bodyRef = body;
              body.__el = el;

              // Softer randomized start so each card begins independently
              var baseV = isCoarse ? 1.2 : 0.9;
              Matter.Body.setVelocity(body, {
                x: (Math.random() - 0.5) * baseV,
                y: (Math.random() - 0.5) * baseV,
              });
              body.angularVelocity = (Math.random() - 0.5) * 1.2;

              // --- Mobile long-press ‚Üí kinematic drag (pick-and-move) ---
              (function (cardEl, bd) {
                if (!isCoarse) return; // touch-only behavior
                var pressTimer = null,
                  startX = 0,
                  startY = 0,
                  moved = false,
                  dragging = false; // movement gate
                function clearTimer() {
                  if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                  }
                }
                function beginDrag() {
                  dragging = true;
                  bd.__kinDrag = true;
                  bd.__lastGoodX = bd.position.x;
                  bd.__lastGoodY = bd.position.y;
                  window.__draggingBodies && window.__draggingBodies.add(bd);
                }
                function endDrag() {
                  if (!dragging) return;
                  dragging = false;
                  bd.__kinDrag = false;
                  window.__draggingBodies && window.__draggingBodies.delete(bd);
                  // fling from recentPts
                  if (recentPts.length >= 2) {
                    var a = recentPts[0],
                      z = recentPts[recentPts.length - 1];
                    var dt = (z.t - a.t) / 1000;
                    if (dt > 0) {
                      var vx = (z.x - a.x) / dt,
                        vy = (z.y - a.y) / dt;
                      var CL = 1200;
                      vx = Math.max(-CL, Math.min(CL, vx));
                      vy = Math.max(-CL, Math.min(CL, vy));
                      Matter.Body.setVelocity(bd, { x: vx / 60, y: vy / 60 });
                      bd.angularVelocity += (Math.random() - 0.5) * 0.6;
                    }
                  }
                  recentPts.length = 0;
                }
                cardEl.addEventListener(
                  "touchstart",
                  function (e) {
                    if (!e.touches || !e.touches[0]) return;
                    moved = false;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    clearTimer();
                    pressTimer = setTimeout(function () {
                      if (!moved) {
                        beginDrag();
                      }
                    }, 220);
                  },
                  { passive: true, capture: true }
                );
                cardEl.addEventListener(
                  "touchmove",
                  function (e) {
                    if (!e.touches || !e.touches[0]) return;
                    var x = e.touches[0].clientX,
                      y = e.touches[0].clientY;
                    var dx = x - startX,
                      dy = y - startY;
                    if (dx * dx + dy * dy > 100) {
                      moved = true;
                    }
                    if (dragging) {
                      pushPointer(x, y);
                      bd.__kinX = x;
                      bd.__kinY = y;
                    }
                  },
                  { passive: true }
                );
                cardEl.addEventListener(
                  "touchend",
                  function () {
                    clearTimer();
                    if (dragging) endDrag();
                  },
                  { passive: true, capture: true }
                );
              })(el, body);
            });
            // NEW: bind to document so overlay never eats scroll
            var mouse = Mouse.create(document.body);
            mouse.pixelRatio = window.devicePixelRatio || 1;

            var mc = MouseConstraint.create(engine, {
              mouse,
              constraint: {
                stiffness: 0.14, // gentler, less "sticky"
                damping: 0.22,
                angularStiffness: 0, // allow free rotation while held
                render: { visible: false },
              },
            });
            Composite.add(engine.world, mc);
            // Force headless coordinates to be viewport-based (ignore element offsets)
            try {
              mc.mouse.offset.x = 0;
              mc.mouse.offset.y = 0;
              mc.mouse.scale.x = 1;
              mc.mouse.scale.y = 1;
            } catch (_) {}

            // Make a bit stickier on fine pointers
            var finePointer =
              window.matchMedia && window.matchMedia("(pointer: fine)").matches;
            if (finePointer && mc.constraint) {
              mc.constraint.stiffness = 0.22;
              mc.constraint.angularStiffness = 0;
            }
            // Allow taps + drags without blocking scroll
            if (mc.mouse && mc.mouse.element) {
              mc.mouse.element.style.touchAction = "pan-y"; // allow vertical scroll on wheel/touchpads
            }

            // Track dragging bodies so clicks during a drag don't trigger play()
            var dragging = new Set();
            window.__draggingBodies = dragging;

            // --- Recent-pointer velocity sampler for fling throws ---
            var recentPts = []; // [{x,y,t}, ...] ~140ms window
            var MAX_AGE_MS = 140;
            function pushPointer(x, y) {
              var now = performance.now();
              recentPts.push({ x: x, y: y, t: now });
              while (recentPts.length && now - recentPts[0].t > MAX_AGE_MS) {
                recentPts.shift();
              }
            }

            // Feed the sampler *only while dragging*
            var __onMouseMove = function (e) {
              // Keep Matter's mouse in viewport coordinates so picking works at any scrollY
              mc.mouse.position.x = e.clientX;
              mc.mouse.position.y = e.clientY;
              if (mc.body) pushPointer(e.clientX, e.clientY);
            };
            var __onTouchMove = function (e) {
              if (e.touches && e.touches[0]) {
                var x = e.touches[0].clientX,
                  y = e.touches[0].clientY;
                mc.mouse.position.x = x;
                mc.mouse.position.y = y;
                if (mc.body) pushPointer(x, y);
              }
            };
            window.addEventListener("mousemove", __onMouseMove, {
              passive: true,
            });
            window.addEventListener("touchmove", __onTouchMove, {
              passive: true,
            });
            __cleanup.push(function () {
              window.removeEventListener("mousemove", __onMouseMove);
              window.removeEventListener("touchmove", __onTouchMove);
            });

            // Track the most recent down event for tap-vs-drag decisions
            var __lastDown = { t: 0, x: 0, y: 0 };
            document.addEventListener(
              "mousedown",
              function (e) {
                __lastDown.t = performance.now();
                __lastDown.x = e.clientX;
                __lastDown.y = e.clientY;
              },
              true
            );
            document.addEventListener(
              "touchstart",
              function (e) {
                if (e.touches && e.touches[0]) {
                  __lastDown.t = performance.now();
                  __lastDown.x = e.touches[0].clientX;
                  __lastDown.y = e.touches[0].clientY;
                }
              },
              { passive: true, capture: true }
            );

            // Capture clicks anywhere on the page and dispatch to the topmost flying-card under the pointer.
            // This ensures click-to-play works even when the overlay itself is not the event target (e.g., near the hero/nav).
            function cardMetaAt(x, y) {
              for (var i = bodies.length - 1; i >= 0; i--) {
                var el = bodies[i].el;
                var r = el.getBoundingClientRect();
                if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom)
                  return bodies[i];
              }
              return null;
            }
            var __onDocClick = function (ev) {
              // Only when floating
              var html = document.documentElement;
              if (
                !(
                  html.classList.contains("party") ||
                  html.classList.contains("float-on")
                )
              )
                return;
              var x = ev.clientX,
                y = ev.clientY;
              if (typeof x !== "number" || typeof y !== "number") return;
              // If the topmost element is nav or not a flying card, don't hijack the click
              var topEl = document.elementFromPoint(x, y);
              if (topEl) {
                if (topEl.closest && topEl.closest("#nav")) return;
                if (!(topEl.closest && topEl.closest(".flying-card"))) return;
              }
              // ignore if a drag just occurred or distance/time exceeds tap thresholds
              var moved2 = Infinity;
              if (typeof recentPts !== "undefined" && recentPts.length >= 2) {
                var a = recentPts[0],
                  z = recentPts[recentPts.length - 1];
                moved2 = (z.x - a.x) * (z.x - a.x) + (z.y - a.y) * (z.y - a.y);
              } else if (typeof __lastDown !== "undefined" && __lastDown.t) {
                var dx = x - __lastDown.x,
                  dy = y - __lastDown.y;
                moved2 = dx * dx + dy * dy;
              }
              var dtTap =
                typeof __lastDown !== "undefined" && __lastDown.t
                  ? performance.now() - __lastDown.t
                  : 0;
              // Treat tiny drags (<10px and <320ms) as taps; otherwise, suppress play
              if (!(moved2 <= 10 * 10 && dtTap <= 320)) return;
              var meta = cardMetaAt(x, y);
              if (!meta) return;
              // Prevent underlying links from firing when we intent to play
              ev.stopPropagation();
              // Gesture-qualified play path (click)
              if (meta && meta.el && meta.el.__track) {
                playTrackSrc(meta.el.__track, meta.el);
              }
            };
            document.addEventListener("click", __onDocClick, true);
            __cleanup.push(function () {
              document.removeEventListener("click", __onDocClick, true);
            });

            // Start/End drag hooks
            Events.on(mc, "startdrag", function (e) {
              if (e && e.body) {
                dragging.add(e.body);
                // wake up just in case
                if (Matter.Sleeping && Matter.Sleeping.set) {
                  Matter.Sleeping.set(e.body, false);
                }
                // Stick under pointer: stop motion immediately and stiffen grip slightly
                try {
                  Matter.Body.setVelocity(e.body, { x: 0, y: 0 });
                  e.body.angularVelocity = 0;
                } catch (_) {}
                if (mc && mc.constraint) {
                  mc.constraint.__prevStiff = mc.constraint.stiffness;
                  mc.constraint.stiffness = Math.max(
                    mc.constraint.stiffness,
                    0.35
                  );
                }
                // Brief glow flash on held
                try {
                  var __el = e.body.__el;
                  if (__el) {
                    __el.classList.add("held");
                    if (__el.__heldTimer) {
                      clearTimeout(__el.__heldTimer);
                    }
                    __el.__heldTimer = setTimeout(function () {
                      __el.classList.remove("held");
                      __el.__heldTimer = null;
                    }, 500);
                  }
                } catch (_) {}
              }
              recentPts.length = 0; // fresh sample window
            });

            Events.on(mc, "enddrag", function (e) {
              var b = e && e.body;
              if (!b) return;
              dragging.delete(b);
              if (
                mc &&
                mc.constraint &&
                typeof mc.constraint.__prevStiff === "number"
              ) {
                mc.constraint.stiffness = mc.constraint.__prevStiff;
                mc.constraint.__prevStiff = undefined;
              }

              // Compute fling velocity from the sample window
              if (recentPts.length >= 2) {
                var a = recentPts[0];
                var z = recentPts[recentPts.length - 1];
                var dt = (z.t - a.t) / 1000; // sec
                if (dt > 0) {
                  var vx = (z.x - a.x) / dt; // px/s
                  var vy = (z.y - a.y) / dt; // px/s

                  // clamp and convert to Matter units (approx px/frame at 60fps)
                  var CLAMP = 1200;
                  vx = Math.max(-CLAMP, Math.min(CLAMP, vx));
                  vy = Math.max(-CLAMP, Math.min(CLAMP, vy));
                  Matter.Body.setVelocity(b, { x: vx / 60, y: vy / 60 });

                  // give it a little spin on release
                  b.angularVelocity += (Math.random() - 0.5) * 0.7;
                }
              }
              recentPts.length = 0;
            });

            // Scroll impulse ‚Üí push cards in scroll direction
            var lastY = window.scrollY;
            var __onScroll = function () {
              var dy = window.scrollY - lastY;
              lastY = window.scrollY;
              if (!dy) return;
              var mag = Math.min(40, Math.abs(dy) * 0.6);
              var signY = dy > 0 ? 1 : -1;
              bodies.forEach(function (b) {
                var bx = b.body.position.x,
                  by = b.body.position.y;
                var fx = (Math.random() - 0.5) * 0.02 * mag * 1e-3;
                var fy = signY * 0.025 * mag * 1e-3;
                Matter.Body.applyForce(
                  b.body,
                  { x: bx, y: by },
                  { x: fx, y: fy }
                );
                b.body.angularVelocity +=
                  (Math.random() - 0.5) * 0.04 * (mag / 12);
              });
              jostle(260, Math.min(2.4, 0.6 + mag / 18));
            };
            addEventListener("scroll", __onScroll, { passive: true });
            __cleanup.push(function () {
              removeEventListener("scroll", __onScroll);
            });

            // Desktop wheel adds extra oomph (high-res delta)
            var __lastWheelJostle = 0;
            var __onWheel = function (e) {
              var dy = e.deltaY || 0;
              if (!dy) return;
              var now = performance.now();
              if (now - __lastWheelJostle < 120) return; // throttle
              __lastWheelJostle = now;
              var mag = Math.min(48, Math.abs(dy) * 0.28);
              var signY = dy > 0 ? 1 : -1;
              bodies.forEach(function (b) {
                var fx = (Math.random() - 0.5) * 0.03 * mag * 1e-3;
                var fy = signY * 0.03 * mag * 1e-3;
                Matter.Body.applyForce(b.body, b.body.position, {
                  x: fx,
                  y: fy,
                });
                b.body.angularVelocity +=
                  (Math.random() - 0.5) * 0.05 * (mag / 18);
              });
              jostle(300, Math.min(3, 0.8 + mag / 20));
            };
            addEventListener("wheel", __onWheel, { passive: true });
            __cleanup.push(function () {
              removeEventListener("wheel", __onWheel);
            });

            // Touch drag = jostle as you scroll with your finger
            var __lastJostle = 0;
            var __onTouchScroll = function (e) {
              var touches = e.touches;
              if (!touches || !touches[0]) return;
              var now = performance.now();
              if (now - __lastJostle < 180) return; // throttle
              __lastJostle = now;
              jostle(180, 1.0);
            };
            addEventListener("touchmove", __onTouchScroll, { passive: true });
            __cleanup.push(function () {
              removeEventListener("touchmove", __onTouchScroll);
            });

            // Headless render: copy body transforms to DOM
            function render() {
              for (var i = 0; i < bodies.length; i++) {
                var b = bodies[i];
                var x = b.body.position.x - b.w / 2;
                var y = b.body.position.y - b.h / 2;
                var a = b.body.angle;
                var t =
                  "translate3d(" +
                  x.toFixed(1) +
                  "px," +
                  y.toFixed(1) +
                  "px,0) rotate(" +
                  a.toFixed(3) +
                  "rad)";
                b.el.style.transform = t;
              }
            }

            // Resize walls on viewport resize
            var onResize = function () {
              // remove old walls
              Composite.allBodies(engine.world)
                .filter((b) => b.label === "wall")
                .forEach((w) => Composite.remove(engine.world, w));

              // rebuild with the current viewport size/thickness rules
              makeWalls();
            };
            addEventListener("resize", onResize);
            __cleanup.push(function () {
              removeEventListener("resize", onResize);
            });

            // Replace Runner with a single RAF driving both physics and render
            var __last = performance.now();
            function tick(t) {
              var dt = Math.min(1000 / 30, t - __last); // cap dt to 33ms for stability
              __last = t;
              try {
                Engine.update(engine, dt);
              } catch (_) {}
              render();
              requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);

            // Perpetual wander: each card has a heading vector that slowly
            // drifts. We push along heading + tiny noise so motion feels
            // one-directional and natural.
            Events.on(engine, "beforeUpdate", function (ev) {
              var dt = (ev.delta || 1000 / 60) / 1000; // seconds
              __idleT += dt;
              var TAU = Math.PI * 2;
              for (var i = 0; i < bodies.length; i++) {
                var bd = bodies[i].body;
                // Kinematic drag: follow finger when active (touch-only path)
                if (
                  bd.__kinDrag &&
                  typeof bd.__kinX === "number" &&
                  typeof bd.__kinY === "number"
                ) {
                  var tx = bd.__kinX,
                    ty = bd.__kinY;
                  // Find meta (size) for this body
                  var metaSelf = null;
                  for (var mi = 0; mi < bodies.length; mi++) {
                    if (bodies[mi].body === bd) {
                      metaSelf = bodies[mi];
                      break;
                    }
                  }
                  if (metaSelf) {
                    var hw = metaSelf.w * 0.5,
                      hh = metaSelf.h * 0.5;
                    var pad = 18; // keep off exact edges
                    tx = Math.max(
                      pad + hw,
                      Math.min(innerWidth - pad - hw, tx)
                    );
                    ty = Math.max(
                      pad + hh,
                      Math.min(innerHeight - pad - hh, ty)
                    );
                    // Block overlaps with other cards using simple AABB test
                    var blocked = false;
                    for (var mj = 0; mj < bodies.length; mj++) {
                      var other = bodies[mj];
                      if (other.body === bd) continue;
                      var ox = other.body.position.x,
                        oy = other.body.position.y;
                      var ohw = other.w * 0.5,
                        ohh = other.h * 0.5;
                      if (
                        tx + hw > ox - ohw &&
                        tx - hw < ox + ohw &&
                        ty + hh > oy - ohh &&
                        ty - hh < oy + ohh
                      ) {
                        blocked = true;
                        break;
                      }
                    }
                    if (!blocked) {
                      Matter.Body.setPosition(bd, { x: tx, y: ty });
                      bd.__lastGoodX = tx;
                      bd.__lastGoodY = ty;
                    } else if (typeof bd.__lastGoodX === "number") {
                      Matter.Body.setPosition(bd, {
                        x: bd.__lastGoodX,
                        y: bd.__lastGoodY,
                      });
                    }
                  } else {
                    Matter.Body.setPosition(bd, { x: tx, y: ty });
                  }
                }
                // Angular damping (approx) for mobile for a smoother settle
                if (isCoarse && bd.angularVelocity) {
                  var damp = 0.08; // ~0.06‚Äì0.1
                  bd.angularVelocity *= Math.max(0, 1 - damp * dt);
                }
                if (!bd.__wander) {
                  // heading angle, speed scalar, and a timer for small course changes
                  bd.__wander = {
                    ang: Math.random() * Math.PI * 2,
                    speed: 0.00042 + Math.random() * 0.00038,
                    turnTimer: 0.8 + Math.random() * 1.4,
                  };
                }
                var w = bd.__wander;
                // occasionally perturb heading a little so paths diverge
                w.turnTimer -= dt;
                if (w.turnTimer <= 0) {
                  w.ang += (Math.random() - 0.5) * 0.6; // small course change
                  w.speed = Math.max(
                    0.00025,
                    Math.min(0.0009, w.speed + (Math.random() - 0.5) * 0.00025)
                  );
                  w.turnTimer = 0.8 + Math.random() * 1.6;
                }
                var fx =
                  Math.cos(w.ang) * w.speed + (Math.random() - 0.5) * 0.00002;
                var fy =
                  Math.sin(w.ang) * w.speed + (Math.random() - 0.5) * 0.00002;
                Matter.Body.applyForce(bd, bd.position, { x: fx, y: fy });
                // Slight continuous spin, gentler than before
                var targetSpin = 0.012 * (Math.random() > 0.5 ? 1 : -1);
                if (Math.abs(bd.angularVelocity) < 0.04) {
                  bd.angularVelocity += targetSpin * dt;
                }
                // Independent idle drift (per-card seeds + per-card time offset)
                if (bd.__idle) {
                  var s = bd.__idle;
                  var localT = __idleT + (s.t0 || 0); // de-sync timelines per card
                  // --- soft containment / wrap-back ---
                  var Wv = innerWidth,
                    Hv = innerHeight;
                  var pad = 40; // live area inset
                  var kEdge = 0.0005; // gentle pull
                  var kWrap = 0.9; // reduce velocity if teleported

                  var px = bd.position.x,
                    py = bd.position.y;
                  if (px < pad) {
                    Matter.Body.applyForce(bd, bd.position, { x: kEdge, y: 0 });
                  } else if (px > Wv - pad) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -kEdge,
                      y: 0,
                    });
                  }
                  if (py < pad) {
                    Matter.Body.applyForce(bd, bd.position, { x: 0, y: kEdge });
                  } else if (py > Hv - pad) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0,
                      y: -kEdge,
                    });
                  }

                  // emergency wrap (if somehow far outside)
                  var out = 200;
                  if (
                    px < -out ||
                    px > Wv + out ||
                    py < -out ||
                    py > Hv + out
                  ) {
                    Matter.Body.setPosition(bd, {
                      x: Math.min(Math.max(pad, px), Wv - pad),
                      y: Math.min(Math.max(pad, py), Hv - pad),
                    });
                    Matter.Body.setVelocity(bd, {
                      x: bd.velocity.x * kWrap,
                      y: bd.velocity.y * kWrap,
                    });
                  }

                  // --- anti-corner nudge: if near a corner, push diagonally back in ---
                  var near = 42; // corner proximity threshold
                  var vx = bd.velocity.x,
                    vy = bd.velocity.y;
                  // top-left
                  if (px < pad + near && py < pad + near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0.0012,
                      y: 0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x += 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y += 0.3;
                  }
                  // top-right
                  else if (px > Wv - pad - near && py < pad + near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -0.0012,
                      y: 0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x -= 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y += 0.3;
                  }
                  // bottom-left
                  else if (px < pad + near && py > Hv - pad - near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: 0.0012,
                      y: -0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x += 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y -= 0.3;
                  }
                  // bottom-right
                  else if (px > Wv - pad - near && py > Hv - pad - near) {
                    Matter.Body.applyForce(bd, bd.position, {
                      x: -0.0012,
                      y: -0.0012,
                    });
                    if (Math.abs(vx) < 0.3) bd.velocity.x -= 0.3;
                    if (Math.abs(vy) < 0.3) bd.velocity.y -= 0.3;
                  }

                  // sinusoidal micro-forces with unique freq & phase per axis
                  var fxIdle = Math.sin(TAU * s.fx * localT + s.px) * s.ax;
                  var fyIdle = Math.sin(TAU * s.fy * localT + s.py) * s.ay;

                  Matter.Body.applyForce(bd, bd.position, {
                    x: fxIdle,
                    y: fyIdle,
                  });

                  // ambient vector field (very gentle, position + time dependent)
                  var vfx =
                    Math.sin(bd.position.y * 0.002 + __idleT * 0.15) * 0.00008;
                  var vfy =
                    Math.cos(bd.position.x * 0.002 - __idleT * 0.12) * 0.00008;
                  Matter.Body.applyForce(bd, bd.position, { x: vfx, y: vfy });

                  // tiny continuous orientation wander so cards gently rotate even at rest
                  var rotNudge =
                    Math.sin(TAU * (s.fx * 0.42) * localT + s.px * 0.37) *
                    0.00003;
                  bd.torque += rotNudge;
                  // ensure a tiny baseline drift so nothing fully stalls
                  var baseDrift = 0.00005;
                  Matter.Body.applyForce(bd, bd.position, {
                    x: (Math.random() - 0.5) * baseDrift,
                    y: (Math.random() - 0.5) * baseDrift,
                  });
                  // gently wake if velocity is extremely low
                  var v2 =
                    bd.velocity.x * bd.velocity.x +
                    bd.velocity.y * bd.velocity.y;
                  if (v2 < 0.00002) {
                    if (Matter.Sleeping && Matter.Sleeping.set)
                      Matter.Sleeping.set(bd, false);
                    bd.velocity.x += (Math.random() - 0.5) * 0.16;
                    bd.velocity.y += (Math.random() - 0.5) * 0.16;
                    bd.angularVelocity += (Math.random() - 0.5) * 0.035;
                  }
                }
              }
            });

            // Cursor/Finger magnet: sticky, local attraction only when hovering a card
            (function () {
              var mx = 0,
                my = 0,
                hasMouse = false,
                tx = 0,
                ty = 0,
                hasTouch = false;
              document.addEventListener(
                "mousemove",
                function (e) {
                  mx = e.clientX;
                  my = e.clientY;
                  hasMouse = true;
                },
                { passive: true }
              );
              document.addEventListener(
                "touchmove",
                function (e) {
                  if (!e.touches || !e.touches[0]) return;
                  tx = e.touches[0].clientX;
                  ty = e.touches[0].clientY;
                  hasTouch = true;
                },
                { passive: true }
              );

              function metaForBody(bd) {
                for (var i = 0; i < bodies.length; i++) {
                  if (bodies[i].body === bd) return bodies[i];
                }
                return null;
              }

              Events.on(engine, "afterUpdate", function () {
                if (!(hasMouse || hasTouch) || !bodies.length) return;

                // find nearest card center
                var nearest = null,
                  bestD2 = Infinity;
                for (var i = 0; i < bodies.length; i++) {
                  var bd = bodies[i].body;
                  var hx = hasTouch ? tx : mx;
                  var hy = hasTouch ? ty : my;
                  var dx = hx - bd.position.x;
                  var dy = hy - bd.position.y;
                  var d2 = dx * dx + dy * dy;
                  if (d2 < bestD2) {
                    bestD2 = d2;
                    nearest = bd;
                  }
                }
                if (!nearest) return;

                var meta = metaForBody(nearest);
                if (!meta) return;

                // Only attract when cursor is essentially "hovering" the card:
                // use a radius equal to ~the card size (half the diagonal).
                var halfDiag =
                  0.5 * Math.sqrt(meta.w * meta.w + meta.h * meta.h);
                var radius = Math.max(halfDiag * 0.9, 60); // sticky only when close
                if (bestD2 > radius * radius) return;

                // Small pull so it feels sticky, not grabby
                var d = Math.sqrt(bestD2);
                var pull = 0.000035 * (1 - d / radius); // weaker and very local
                var hx = hasTouch ? tx : mx;
                var hy = hasTouch ? ty : my;
                var fx = (hx - nearest.position.x) * pull;
                var fy = (hy - nearest.position.y) * pull;
                Matter.Body.applyForce(nearest, nearest.position, {
                  x: fx,
                  y: fy,
                });
              });
            })();

            // Impacts add spin; also free inertia after first bounce for natural rotation
            Events.on(engine, "collisionStart", function (evt) {
              var pairs = evt.pairs || [];
              for (var i = 0; i < pairs.length; i++) {
                var a = pairs[i].bodyA,
                  b = pairs[i].bodyB;

                [a, b].forEach(function (body) {
                  if (body.label && String(body.label).indexOf("card-") === 0) {
                    if (body.inertia === Infinity) {
                      // allow rotation after first hit
                      Matter.Body.setInertia(
                        body,
                        (body.mass *
                          Math.max(40, body.bounds.max.x - body.bounds.min.x) **
                            2) /
                          12
                      );
                    }
                    body.angularVelocity += (Math.random() - 0.5) * 0.07; // subtler spin-on-impact
                  }
                });
              }
            });
          }

          // Maintain original grid + cards, listeners, and teardown
          var __originalCards = [];
          var __grid = null;
          var __cleanup = [];

          function start() {
            if (ACTIVE) return;
            ACTIVE = true;
            document.documentElement.classList.add("float-on");
            buildWorld();
          }

          function stop() {
            if (!ACTIVE) return;
            ACTIVE = false;
            document.documentElement.classList.remove("float-on");

            // Cancel RAF for headless render
            if (ticking) {
              cancelAnimationFrame(ticking);
              ticking = 0;
            }

            // Remove event listeners registered during build
            try {
              for (var i = 0; i < __cleanup.length; i++) __cleanup[i]();
            } catch (_) {}
            __cleanup.length = 0;

            // Stop Matter engine/runner
            try {
              if (runner) Matter.Runner.stop(runner);
            } catch (_) {}
            runner = null;
            try {
              if (engine) Matter.Composite.clear(engine.world, false, true);
            } catch (_) {}
            engine = null;

            // Move the six cards back to the Services grid in original order
            if (__grid && __originalCards && __originalCards.length) {
              __originalCards.forEach(function (el) {
                // remove float-only classes and inline styles
                el.classList.remove(
                  "flying-card",
                  "no-drag",
                  "launching",
                  "swap-on",
                  "playing"
                );
                el.style.transform = "";
                el.style.width = "";
                el.style.height = "";
                el.style.position = "";
                el.style.left = "";
                el.style.top = "";
                el.style.pointerEvents = "";
                el.style.background = "";
                el.style.color = "";
                el.style.willChange = "";
                el.style.userSelect = "";
                el.style.webkitUserSelect = "";
                el.style.webkitUserDrag = "";
                el.style.webkitTapHighlightColor = "";

                // restore original content visibility
                el.querySelectorAll("h3,p").forEach(function (n) {
                  n.style.display = "";
                  n.style.opacity = "";
                  n.style.visibility = "";
                  n.style.height = "";
                  n.style.margin = "";
                  n.style.pointerEvents = "";
                });
                var swap = el.querySelector(".title-swap");
                if (swap && swap.parentNode) swap.parentNode.removeChild(swap);

                __grid.appendChild(el);
              });
            }

            bodies = [];
          }

          // Expose to Party toggle
          window.__startFloatMode = start;
          window.__stopFloatMode = stop;
          window.__debugFloat = {
            on: false,
            set: function (on) {
              this.on = !!on;
              console.log("[float] debug", this.on ? "on" : "off");
            },
          };
        })();

        /* Reveal (replayable) */
        var els = [].slice.call(document.querySelectorAll("[data-animate]"));
        if ("IntersectionObserver" in window) {
          try {
            var io = new IntersectionObserver(
              function (entries) {
                for (var i = 0; i < entries.length; i++) {
                  var e = entries[i];
                  if (e.isIntersecting) e.target.classList.add("reveal");
                  else e.target.classList.remove("reveal");
                }
              },
              { rootMargin: "0px 0px -10% 0px", threshold: 0.1 }
            );
            els.forEach(function (el) {
              io.observe(el);
            });
          } catch (_) {
            els.forEach(function (el) {
              el.classList.add("reveal");
            });
          }
        } else {
          els.forEach(function (el) {
            el.classList.add("reveal");
          });
        }

        /* Drift (global) */
        var driftNodes = [].slice.call(
          document.querySelectorAll("[data-parallax],[data-drift]")
        );
        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }
        function driftTick() {
          var vh = window.innerHeight || 1;
          var sc = d.scrollTop || b.scrollTop;
          var rawScale = getComputedStyle(d)
            .getPropertyValue("--drift-scale")
            .trim();
          var scale = parseFloat(rawScale);
          if (isNaN(scale)) scale = 1;

          for (var i = 0; i < driftNodes.length; i++) {
            var el = driftNodes[i];
            var multY = parseFloat(el.getAttribute("data-drift"));
            if (!(multY || multY === 0))
              multY = el.hasAttribute("data-parallax") ? 1.2 : 0.7;
            var multX = parseFloat(el.getAttribute("data-drift-x"));
            if (!(multX || multX === 0)) multX = 0.55 * multY;

            var r = el.getBoundingClientRect();
            var center = r.top + r.height / 2;
            var norm = (center - vh / 2) / vh;

            // Stronger, more obvious drift (tunable via --drift-scale and Lab)
            var y = clamp(-60 * norm * multY * scale, -90, 90);
            var x = Math.sin(sc * 0.006 + i * 0.9) * (22 * multX * scale);

            el.style.setProperty("--dy", y + "px");
            el.style.setProperty("--dx", x + "px");
          }
          requestAnimationFrame(driftTick);
        }
        requestAnimationFrame(driftTick);

        /* Scroll progress */
        var bar = document.getElementById("scroll-progress");
        function progress() {
          var sc = d.scrollTop || b.scrollTop,
            max = d.scrollHeight - d.clientHeight || 1;
          if (bar) bar.style.width = (sc / max) * 100 + "%";
        }
        progress();
        document.addEventListener("scroll", progress, { passive: true });

        /* Mobile nav toggle */
        (function () {
          var nav = document.getElementById("nav");
          var btn = document.getElementById("nav-toggle");
          if (!nav || !btn) return;
          btn.addEventListener("click", function () {
            nav.classList.toggle("open");
          });
        })();

        /* Detect touch / coarse pointer for mobile behavior */
        var IS_COARSE =
          window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
        // Soften drift and thicken morph on mobile/tablet
        d.style.setProperty("--drift-scale", IS_COARSE ? 0.75 : 1.0);
        d.style.setProperty("--morph-stroke-min", IS_COARSE ? 16 : 22);
        d.style.setProperty("--morph-stroke-max", IS_COARSE ? 28 : 36);
        // ensure a default color exists so Lab can read/override
        if (
          !getComputedStyle(d).getPropertyValue("--morph-stroke-color").trim()
        ) {
          d.style.setProperty("--morph-stroke-color", "#2f6f64");
        }

        // end vibe core IIFE
      })();

      // ===== Dark/Light mode toggle =====
      (function () {
        const toggleBtn = document.querySelector(".theme-toggle");
        if (!toggleBtn) return;
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        const savedTheme = localStorage.getItem("theme");
        function setTheme(theme) {
          document.body.classList.remove("dark-mode", "light-mode");
          document.body.classList.add(theme + "-mode");
          document.documentElement.classList.remove("dark-mode", "light-mode");
          document.documentElement.classList.add(theme + "-mode");
          toggleBtn.textContent = theme === "dark" ? "üåû" : "üåô";
          localStorage.setItem("theme", theme);
        }
        // Initial theme
        if (savedTheme) {
          setTheme(savedTheme);
        } else {
          setTheme(prefersDark ? "dark" : "light");
        }
        // Toggle handler
        toggleBtn.addEventListener("click", () => {
          const current = document.body.classList.contains("dark-mode")
            ? "dark"
            : "light";
          setTheme(current === "dark" ? "light" : "dark");
        });
      })();
    </script>
  </body>
</html>
